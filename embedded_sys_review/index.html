<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"megalomania.icu","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="SSDUT智能技术系统方向大三专业课复习提纲，建议多背( •̀ ω •́ )✧ 代码一定要会写啊kora！(＃°Д°)">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式系统与组成原理—提纲">
<meta property="og:url" content="https://megalomania.icu/embedded_sys_review/index.html">
<meta property="og:site_name" content="Megalomania">
<meta property="og:description" content="SSDUT智能技术系统方向大三专业课复习提纲，建议多背( •̀ ω •́ )✧ 代码一定要会写啊kora！(＃°Д°)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.megalomania.icu/images/ch1-1.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/ch2-1.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/ch2-2.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/8ac2d152cc60414c9b7ac150e08eebc9.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/06856245f71e71dc4b6e77753fe3e72c.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7389d5f54492c758094b9665351a626e.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/48c42dab1288ecb7a1cf6dc60cd1d132.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7055bddc2574b7f987bb3d87d0dd969d.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/4c702fa4249bc320fdac8758fb4fcfbd.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/0a3c54f45c85b999c254bba6219f0a89.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/f42600e01ba027ed9ccfc01e803ea0c8.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/0b969ad7b5aef8bdb018234720cda583.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/0a9b2bff24dfd6755ea586b51a967662.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/e46322dede506b7bcca8d7122b8ea030.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/089de0568dc393779bd6db6b81e67b97.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/25113639859bc64d1da56ad72cbaa375.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/be492bb4e5ca058e29674441c415c992.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/12bbe55aeedd66ed93d382ce34d45666.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/9e8d6de1c674f2097b99c8ca0740b5ce.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/b5d9b0c5b4f9cc8de0e4c6600613f9e7.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/1cc4bd59f60f90a0c7c88e45240d0fea.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/bd7b89fe4b0f51cf4dce844a6b2e5564.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/40b8d91fdfc2b4dcd3863d7789723d43.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/4433f1193ba575a2d4e109771c6226cf.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/365b26fac29a5f15f7605a55c24ae8ae.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/f669609fdb8b31824940ccc875cc16cc.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/0a6a40c9950f58ea73683fa8c9824687.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/6ee0ff0cd1e5e2b381e6db9e503b0562.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/f440793da4ce61807f0c90d2b4c60f13.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7634c590cf8d1ba1a6d4e290749ad537.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/5765315414c31541336581706e9633a2.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/d5782364cdf318299742c9ae03eeda90.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/a1611f819355dc875bd1fa50be7acf16.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/dc3de4fc197aa62bc0341851cc217d63.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/209c22ec4bca761ffc4e1ccf4186e14f.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/2b93e4faa9c07b751567db82537eb141.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/f794660439842458450ed05982d076c7.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/e2b0b2fbc1bc0fdac6e9384afb7ef3b9.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/3e393384c7605e18637bf2dba9d0fc17.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/bd9c9f1705bf265f1d83c39028ec089a.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/57f34def6e4eaaab731e00558eeadba2.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/60472be9fbe72cca441f812c9586c080.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/91ae53905ff16a6de07239cb38a13b1a.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/eecfd50b6295a43b843813ebfb1142d8.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/6a763e6485ac8a200fda501b195f6288.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7961aa7fa8390148da2845159ea16e37.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/bdd43648e2bf084e98762ce56c8a1024.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/cd8f1c506558c2cd8151b01c576ee5db.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/94d0967680d12be1b67cba0d140963ad.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7af1d646702ac2c315845401eddbab1b.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/e9f3479964a76a3a61e3a33758735fce.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7bb4a8c3da26fc64cd50dc03ff7decac.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/c8809486801c45f943988a4cf7960ad8.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/987442d923b2bcb685d157ae92543b1d.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/559ebfe2bfad7720a61b5d7df72429d9.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7e7a52b0ed4eae5a5c959c578f016da2.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/390c136c780ea0b4566b96743523edbb.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/1e51f3f42d8d940fb8f55a849481f795.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/b42aae6bbcefe8da7ac83384f1e85a37.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/68e603b03a4dec85dae66b34ecc563b1.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/2efada8e1b44c9192668f34e536e044d.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/65ca09d4bb9e1d58afdf7790e5079098.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/5d4f1251fdc4903ec3afbe3cc7297337.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/3a8f647629aa62b71a8fc2a38ae9a7a0.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/e508ec5e3f2e17ed5b71d4cb881641fb.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/37b2a4f06f3391dac9232e681cfa41f0.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/0e04e6a0091e2ec1d6c44a927c75ee0a.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/6293f134534a8c9804828dc247d05074.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/2b2b16e20e2c1e2383e2bc0e1bfacec5.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/f7fd7aca3071e3108c2c5b9957c1cf8e.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7c10724721cb29d6e15dc5d004e79dc3.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/8319dfa3e428fed1c45fc10c279a5657.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/8870b8c26a8c27006f3c7d934b35dc04.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/a3350d706af9cb82c9cf29e6cfe2377d.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/0b69547b3eadc44a896ece257c1b405e.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/4f8d828e18a1125f76eff5a12bf4e5f0.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/2b93e4faa9c07b751567db82537eb141.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/25471652dbabc9b2829fb34b1681407b.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/669d643efde561a1a809e0086f45f6eb.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/26705ad147e606394f0ecabbc14b4657.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/d95660ba952372d85307c365593f580b.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/8db994056da6ef4a4cd45dd05e7881f4.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/4ba0649791083ef923428cfaa9acdb2c.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/4d5ce695eeb583720f583ee715ff8482.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/b8247a234ebb00af85a314d37bbb6000.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/49f8e8d1a8a1521c2776c5802b2180b3.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/e1a86fbe2bb55347323298bf7a97f313.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/7d856c22a71503a06f1831b694547843.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/0c975797c4859a504000e6b0f7b1bce6.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/66e8e0a6e442226d74db9b0c6cb5e612.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/9fcebd9adcf3923ae21b72afecf3a2b0.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/4c275a98af46977eb02b11d46cecde9f.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/d1bf181863645a83d93ee7eb94aafaaa.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/569323c30cf2528416df71f55d637e42.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/f35c79457aecb931b880bd74a7a1b5c2.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/928feeb718b34f6048991a6596772322.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/dcc17685b55dcb19f010ba839fc7c6a2.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/0b7a9e4913027782d17afec5870e4504.png">
<meta property="og:image" content="https://cdn.megalomania.icu/images/6fdb4274025c34ce098315a0dcf930fc.png">
<meta property="article:published_time" content="2020-12-01T08:08:34.000Z">
<meta property="article:modified_time" content="2022-08-27T06:38:58.225Z">
<meta property="article:author" content="Shaw Wei">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.megalomania.icu/images/ch1-1.png">

<link rel="canonical" href="https://megalomania.icu/embedded_sys_review/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>嵌入式系统与组成原理—提纲 | Megalomania</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Shaw-W" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Megalomania</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">C.E.P.J.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
    
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://megalomania.icu/embedded_sys_review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Shaw Wei">
      <meta itemprop="description" content="Just do it.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Megalomania">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          嵌入式系统与组成原理—提纲
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 16:08:34" itemprop="dateCreated datePublished" datetime="2020-12-01T16:08:34+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-27 14:38:58" itemprop="dateModified" datetime="2022-08-27T14:38:58+08:00">2022-08-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          
            <span id="/embedded_sys_review/" class="post-meta-item leancloud_visitors" data-flag-title="嵌入式系统与组成原理—提纲" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>36 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>SSDUT智能技术系统方向大三专业课复习提纲，建议多背( •̀ ω •́ )✧</p>
<p>代码一定要会写啊kora！(＃°Д°)</p>
</blockquote>
<a id="more"></a>

<h1 id="一、嵌入式系统的概念"><a href="#一、嵌入式系统的概念" class="headerlink" title="一、嵌入式系统的概念"></a>一、嵌入式系统的概念</h1><h2 id="1、-嵌入式计算机发展总结"><a href="#1、-嵌入式计算机发展总结" class="headerlink" title="1、 嵌入式计算机发展总结"></a>1、 嵌入式计算机发展总结</h2><ul>
<li>嵌入式计算机是诞生于微处理器发展时代</li>
<li>AI进一步驱动了嵌入式计算机的蓬勃发展</li>
</ul>
<h2 id="2、嵌入式系统的分类"><a href="#2、嵌入式系统的分类" class="headerlink" title="2、嵌入式系统的分类"></a>2、嵌入式系统的分类</h2><ul>
<li>按计算机的嵌入式应用和非嵌入式应用将其分为通用计算机和嵌入式计算机。</li>
<li>嵌入式计算机是计算机技术发展中的一种计算机存在的形式，是从计算机技术的发展中分离出来的。</li>
</ul>
<h2 id="3、我国嵌入式系统的行业定义"><a href="#3、我国嵌入式系统的行业定义" class="headerlink" title="3、我国嵌入式系统的行业定义"></a>3、<strong>我国嵌入式系统的行业定义</strong></h2><ul>
<li><strong>以应用为中心</strong>,<strong>以计算机技术为基础</strong>, <strong>软件硬件可裁剪</strong>适应应用系统对功能、可靠性、成本、功耗严格要求的专用计算机系统。</li>
</ul>
<h2 id="4、嵌入式系统的组成结构"><a href="#4、嵌入式系统的组成结构" class="headerlink" title="4、嵌入式系统的组成结构"></a>4、<strong>嵌入式系统的组成结构</strong></h2><img src="https://cdn.megalomania.icu/images/ch1-1.png">

<h2 id="5、硬件基本结构"><a href="#5、硬件基本结构" class="headerlink" title="5、硬件基本结构"></a>5、<strong>硬件基本结构</strong></h2><ul>
<li>嵌入式系统的硬件架构，是以<strong>嵌入式处理器为中心，配置存储器、I/O设备、通信模块以及电源</strong>等必要的辅助接口组成。</li>
<li>嵌入式系统是“量身定做”的“专用计算机应用系统”。（Customize），非常经济、可靠。</li>
</ul>
<h2 id="6、嵌入式系统软件的层次结构"><a href="#6、嵌入式系统软件的层次结构" class="headerlink" title="6、嵌入式系统软件的层次结构"></a>6、嵌入式系统软件的层次结构</h2><ul>
<li>对于使用操作系统的嵌入式系统来说，结构三个层面：<strong>设备驱动层、实时操作系统（RTOS）、实际应用程序层。</strong></li>
</ul>
<h2 id="7、BootLoader"><a href="#7、BootLoader" class="headerlink" title="7、BootLoader"></a>7、BootLoader</h2><ul>
<li>对于PC机，启动初始化由BIOS完成的，对于嵌入式系统来说必须自行编写系统初始化程序，在嵌入式中称为BootLoader程序。</li>
<li>因此在系统加电复位后，处理器将首先执行 Boot Loader 程序。</li>
</ul>
<h1 id="二、ARM技术与ARM体系结构"><a href="#二、ARM技术与ARM体系结构" class="headerlink" title="二、ARM技术与ARM体系结构"></a>二、ARM技术与ARM体系结构</h1><h2 id="1、计算机体系结构分类"><a href="#1、计算机体系结构分类" class="headerlink" title="1、计算机体系结构分类"></a>1、计算机体系结构分类</h2><ul>
<li><p><strong>两种典型的结构 ：</strong></p>
<ul>
<li>冯·诺依曼结构：    <ul>
<li>将数据和指令都存储在存储器中的计算机。</li>
<li>计算系统由一个中央处理单元（CPU）和一个存储器组成。存储器拥有数据和指令，并且可以根据所给的地址对它进行读或写。</li>
</ul>
</li>
<li>哈佛体系结构：    <ul>
<li>为数据和程序提供了各自独立的存储器。</li>
<li>程序计数器只指向程序存储器而不指向数据存储器，这样做的后果是很难在哈佛机上编写出一个自修改的程序 。</li>
<li>独立的程序存储器和数据存储器为数字信号处理提供了较高的性能。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ARM 7使用冯·诺依曼体系结构。</strong></p>
</li>
<li><p><strong>ARM 9使用哈佛体系结构。</strong></p>
</li>
</ul>
<h2 id="2、ISA（Instruction-Set-Architecture）指令集体系结构"><a href="#2、ISA（Instruction-Set-Architecture）指令集体系结构" class="headerlink" title="2、ISA（Instruction-Set Architecture）指令集体系结构"></a>2、ISA（Instruction-Set Architecture）指令集体系结构</h2><ul>
<li>不论从硬件工程师还是软件工程师的角度来看，处理器的设计都是至关重要的。因为支持复杂嵌入式系统设计的能力和设计开发的时间，在可用功能、芯片花费以及最重要的处理器性能上，都会受到指令集体系结构（ISA）的影响。</li>
<li>硬件工程师和软件工程师之间的一个桥梁：    <ul>
<li>硬件工程师根据ISA设计处理器</li>
<li>软件工程师根据ISA写程序</li>
</ul>
</li>
</ul>
<h2 id="3、-ISA模型"><a href="#3、-ISA模型" class="headerlink" title="3、 ISA模型"></a>3、 ISA模型</h2><ul>
<li>ISA模型    <ul>
<li>通用ISA模型    <ul>
<li>复杂指令集计算机（CISC）：Intel x86</li>
<li>精简指令集系统（RISC）：    <ul>
<li>由较少的指令组成的简单操作的体系结构</li>
<li>精简了每个可用操作的周期数的体系结构</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4、ARM"><a href="#4、ARM" class="headerlink" title="4、ARM"></a>4、ARM</h2><ul>
<li><p>ARM代表“高级精简指令集机器”</p>
</li>
<li><p>RISC，Reduced instruction set computer “精简指令集计算机”</p>
<ul>
<li>优势：简单指令的执行速度比复杂指令平均快很多倍，提高了性能。</li>
</ul>
</li>
<li><p>加载/存储（load/store）架构</p>
<ul>
<li>程序员必须在数据被处理之前显式地把数据从存储器加载到寄存器。</li>
<li>同样，程序员必须在数据已被处理后显式地把输出数据存储到寄存器。</li>
<li>所有算数指令以寄存器内容作为输入和结果。</li>
<li>寄存器也可以用来存储临时或者中间结果。</li>
</ul>
</li>
<li><p>三地址架构</p>
<ul>
<li>一个单指令可以涉及三个寄存器</li>
</ul>
</li>
</ul>
<h2 id="5、ARM7微处理器系列"><a href="#5、ARM7微处理器系列" class="headerlink" title="5、ARM7微处理器系列"></a>5、ARM7微处理器系列</h2><ul>
<li>低功耗的32位RISC处理器，冯·诺依曼结构。</li>
<li>具有嵌入式ICE－RT逻辑，调试开发方便。</li>
<li>3级流水线结构。</li>
<li>代码密度高，兼容16位的Thumb指令集。</li>
<li>对操作系统的支持广泛，包括Windows CE、Linux、Palm OS等。</li>
<li>指令系统与ARM9系列、ARM9E系列和ARM10E系列兼容，便于用户的产品升级换代。</li>
<li>主频最高可达130MIPS。</li>
<li>主要应用领域：工业控制、Internet设备、网络和调制解调器设备、移动电话等多种多媒体和嵌入式应用。</li>
</ul>
<h2 id="6、ARM内核模块"><a href="#6、ARM内核模块" class="headerlink" title="6、ARM内核模块"></a>6、ARM内核模块</h2><ul>
<li>ARM处理器一般都带有嵌入式追踪宏单元ETM（Embedded Trace Macro），它是ARM公司自己推出的调试工具。支持CPU运行过程中对实时数据进行仿真。</li>
</ul>
<h2 id="7、ARM流水线技术"><a href="#7、ARM流水线技术" class="headerlink" title="7、ARM流水线技术"></a>7、ARM流水线技术</h2><ul>
<li>流水线技术通过多个功能部件并行工作来缩短程序执行时间，提高处理器的效率和吞吐率。    <ul>
<li>_ARM7_是冯·诺依曼结构，采用了典型的三级流水线，</li>
<li>_ARM9_则是哈佛结构，采用五级流水线技术，</li>
<li>_ARM11_则更是使用了_7_级流水线。</li>
</ul>
</li>
<li>通过增加流水线级数，简化了流水线的各级逻辑，进一步提高了处理器的性能。</li>
</ul>
<h3 id="（1）ARM7三级流水线"><a href="#（1）ARM7三级流水线" class="headerlink" title="（1）ARM7三级流水线"></a>（1）ARM7三级流水线</h3><ul>
<li><p>ARM7系列内核采用了三条流水线的内核结构，三级流水线分别为取指（Fetch）、译码(Decode)、执行(Execute)</p>
<img src="https://cdn.megalomania.icu/images/ch2-1.png">
</li>
<li><p>取指：将指令从存储器中取出，放入指令Cache中。</p>
</li>
<li><p>译码：由译码逻辑单元完成，是将在上一步指令Cache中的指令进行解释，告诉CPU将如何操作。</p>
</li>
<li><p>执行：这阶段包括移位操作、读通用寄存器内容、输出结果、写通用寄存器等。</p>
</li>
<li><p><strong>需要注意的是，PC指向正被取指的指令而不是正在执行的指令</strong></p>
</li>
</ul>
<h3 id="（2）ARM9内核结构"><a href="#（2）ARM9内核结构" class="headerlink" title="（2）ARM9内核结构"></a>（2）ARM9内核结构</h3><ul>
<li>ARM920是一款32位嵌入式RISC处理器内核。在指令操作上采用5级流水线 .    * 取指：从指令Cache中读取指令。<ul>
<li>译码：对指令进行译码，识别出是对哪个寄存器进行操作并从通用寄存器中读取操作数。</li>
<li>执行：进行ALU运算和移位操作，如果是对存储器操作的指令，则在ALU中计算出要访问的存储器地址。</li>
<li>存储器访问：如果是对存储器访问的指令，用来实现数据缓冲功能（通过数据Cache）。</li>
<li>寄存器回写：将指令运算或操作结果写回到目标寄存器中。<img src="https://cdn.megalomania.icu/images/ch2-2.png">

</li>
</ul>
</li>
</ul>
<h2 id="8、ARM处理器的工作模式"><a href="#8、ARM处理器的工作模式" class="headerlink" title="8、ARM处理器的工作模式"></a>8、ARM处理器的工作模式</h2><ul>
<li><p>ARM处理器共有7种工作模式    </p>
<ol>
<li><p>用户模式：非特权模式，也就是正常程序执行的模式，大部分任务在这种模式下执行。</p>
</li>
<li><p>FIQ模式：也称为快速中断模式，支持高速数据传输和通道处理，当一个高优先级(fast)中断产生时将会进入这种模式。</p>
</li>
<li><p>IRQ模式：也称为普通中断模式，:当一个低优先级(normal)中断产生时将会进入这种模式。</p>
</li>
<li><p>SVC模式：称之为管理模式，它是一种操作系统保护模式。当复位或软中断指令执行时处理器将进入这种模式。</p>
</li>
<li><p>中止模式：当存取异常时将会进入这种模式，用来处理存储器故障、实现虚拟存储或存储保护。</p>
</li>
<li><p>未定义指令异常模式：当执行未定义指令时会进入这种模式，主要是用来处理未定义的指令陷阱，支持硬件协处理器的软件仿真，因为未定义指令多发生在对协处理器的操作上。</p>
</li>
<li><p>系统模式：使用和User模式相同寄存器组的特权模式，用来运行特权级的操作系统任务。</p>
</li>
</ol>
</li>
</ul>
<h2 id="9、ARM-寄存器"><a href="#9、ARM-寄存器" class="headerlink" title="9、ARM 寄存器"></a>9、ARM 寄存器</h2><ul>
<li><p>ARM处理器共有37个寄存器，这些寄存器包括以下两类寄存器。</p>
<ol>
<li>31个通用寄存器：包括程序计数器PC等，这些寄存器都是32位寄存器。</li>
<li>6个状态寄存器：状态寄存器也是32位的寄存器，但是目前只使用了其中的14位。</li>
</ol>
</li>
<li><p>1 个用作PC( program counter)</p>
</li>
<li><p>1个用作CPSR(current program status register)</p>
</li>
<li><p>5个用作SPSR(saved program status registers)</p>
</li>
<li><p>30 个通用寄存器</p>
</li>
</ul>
<h2 id="10、程序状态寄存器"><a href="#10、程序状态寄存器" class="headerlink" title="10、程序状态寄存器"></a>10、程序状态寄存器</h2><img src="https://cdn.megalomania.icu/images/8ac2d152cc60414c9b7ac150e08eebc9.png">

<ul>
<li><p>条件位：</p>
<ul>
<li>N = 1-结果为负，0-结果为正或0</li>
<li>Z = 1-结果为0，0-结果不为0</li>
<li>C = 1-进位，0-借位</li>
<li>V =1-结果溢出，0结果没溢出</li>
</ul>
</li>
<li><p>Q 位：</p>
<ul>
<li>仅ARM 5TE/J架构支持</li>
<li>指示增强型DSP指令是否溢出</li>
</ul>
</li>
<li><p>J 位：</p>
<ul>
<li>仅ARM 5TE/J架构支持</li>
<li>J = 1: 处理器处于Jazelle状态</li>
</ul>
</li>
<li><p>中断禁止位：</p>
<ul>
<li>I = 1: 禁止 IRQ.</li>
<li>F = 1: 禁止 FIQ.</li>
</ul>
</li>
<li><p>T Bit：</p>
<ul>
<li>仅ARM xT架构支持</li>
<li>T = 0: 处理器处于 ARM 状态</li>
<li>T = 1: 处理器处于 Thumb 状态</li>
</ul>
</li>
<li><p>Mode位(处理器模式位):</p>
<ul>
<li>0b10000 User</li>
<li>0b10001 FIQ</li>
<li>0b10010 IRQ</li>
<li>0b10011 Supervisor</li>
<li>0b10111 Abort</li>
<li>0b11011 Undefined</li>
<li>0b11111 System</li>
</ul>
</li>
</ul>
<h2 id="11、程序指针PC-r15"><a href="#11、程序指针PC-r15" class="headerlink" title="11、程序指针PC (r15)"></a>11、程序指针PC (r15)</h2><ul>
<li><p>当处理器执行在ARM状态:</p>
<ul>
<li>所有指令 32 bits 宽</li>
<li>所有指令必须 word 对齐</li>
<li>所以 pc值由bits [31:2]决定, bits [1:0] 未定义 (所以指令不能halfword / byte对齐).</li>
</ul>
</li>
<li><p>当处理器执行在Thumb状态:</p>
<ul>
<li>所有指令 16 bits 宽</li>
<li>所有指令必须 halfword 对齐</li>
<li>所以 pc值由bits [31:1]决定, bits [0] 未定义 (所以指令不能 byte对齐).</li>
</ul>
</li>
</ul>
<h2 id="12、ARM异常处理"><a href="#12、ARM异常处理" class="headerlink" title="12、ARM异常处理"></a>12、ARM异常处理</h2><ul>
<li>当正常的程序执行流程发生暂时的停止时，称之为异常。</li>
<li>例如处理一个外部的中断请求。在处理异常之前，当前处理器的状态必须保留，这样当异常处理完成之后，当前程序可以继续执行。</li>
<li>处理器允许多个异常同时发生，它们将会按固定的优先级进行处理。</li>
</ul>
<h3 id="（1）异常入口"><a href="#（1）异常入口" class="headerlink" title="（1）异常入口"></a>（1）异常入口</h3><ul>
<li><p>ARM处理器的异常分为<strong>数据中止</strong>、<strong>快速中断请求</strong>、<strong>普通中断请求</strong>、<strong>预取指中止</strong>、<strong>软件中断</strong>、<strong>复位</strong>及<strong>未定义指令</strong>共7种 。</p>
<table>
<thead>
<tr>
<th><strong>异常类型</strong></th>
<th><strong>处理器模式</strong></th>
<th><strong>优先级</strong></th>
<th><strong>向量表偏移</strong></th>
</tr>
</thead>
<tbody><tr>
<td>复   位</td>
<td>SVC</td>
<td>1</td>
<td>0x00000000</td>
</tr>
<tr>
<td>未定义指令</td>
<td>UND</td>
<td>6</td>
<td>0x00000004</td>
</tr>
<tr>
<td>软件中断SWI</td>
<td>SVC</td>
<td>6</td>
<td>0x00000008</td>
</tr>
<tr>
<td>预取指中止</td>
<td>ABT</td>
<td>5</td>
<td>0x0000000c</td>
</tr>
<tr>
<td>数据中止</td>
<td>ABT</td>
<td>2</td>
<td>0x00000010</td>
</tr>
<tr>
<td>保留</td>
<td>/</td>
<td>/</td>
<td>0x00000014</td>
</tr>
<tr>
<td>IRQ中断</td>
<td>IRQ</td>
<td>4</td>
<td>0x00000018</td>
</tr>
<tr>
<td>FIQ中断</td>
<td>FIQ</td>
<td>3</td>
<td>0x0000001c</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="（2）对异常的响应"><a href="#（2）对异常的响应" class="headerlink" title="（2）对异常的响应"></a>（2）对异常的响应</h3><ul>
<li>当异常产生时, ARM core:    <ul>
<li>拷贝 CPSR 到 SPSR_&lt; mode &gt;</li>
<li>设置适当的 CPSR 位：    <ul>
<li>改变处理器状态进入 ARM 状态</li>
<li>改变处理器模式进入相应的异常模式</li>
<li>设置中断禁止位禁止相应中断 (如果需要)</li>
</ul>
</li>
<li>保存返回地址到 LR_&lt; mode &gt;</li>
</ul>
</li>
<li>设置 PC 位相应的异常向量</li>
<li>返回时, 异常处理需要:    <ul>
<li>从 SPSR _ &lt; mode &gt;恢复CPSR</li>
<li>从LR_&lt; mode &gt;恢复PC</li>
<li>Note:这些操作只能在 ARM 态执行</li>
</ul>
</li>
</ul>
<h2 id="13、外中断处理"><a href="#13、外中断处理" class="headerlink" title="13、外中断处理"></a>13、外中断处理</h2><ul>
<li><p>ARM 有两级外部中断 FIQ，IRQ.</p>
</li>
<li><p>可是大多数的基于ARM 的系统有 &gt;2个的中断源!</p>
<ul>
<li>因此需要一个中断控制器(通常是地址映射的)来控制中断是怎样传递给ARM的。</li>
<li>在许多系统中，一些中断的优先级比其它中断的优先级高，他们要抢先任何正在处理的低优先级中断。</li>
</ul>
</li>
<li><p>Note: 通常中断处理程序总是应该包含_清除中断源的代码_。</p>
</li>
</ul>
<h3 id="（1）FIQ-vs-IRQ"><a href="#（1）FIQ-vs-IRQ" class="headerlink" title="（1）FIQ vs IRQ"></a>（1）FIQ vs IRQ</h3><ul>
<li><p>FIQ 和 IRQ 提供了非常基本的优先级级别。</p>
</li>
<li><p>在下边两种情况下，FIQs有高于IRQs的优先级:</p>
<ul>
<li>当多个中断产生时，FIQ高于IRQ.</li>
<li>处理 FIQ时禁止 IRQs.</li>
<li>IRQs 将不会被响应直到 FIQ处理完成.</li>
</ul>
</li>
<li><p>FIQs 的设计使中断处理尽可能的快.</p>
<ul>
<li>FIQ 向量位于中断向量表的最末.    <ul>
<li>为了使中断处理程序可从中断向量处连续执行</li>
</ul>
</li>
<li>FIQ 模式有5个额外的私有寄存器 (r8-r12)    <ul>
<li>中断处理必须保护其使用的非私有寄存器</li>
</ul>
</li>
<li>可以有多个FIQ中断源,但是考虑到系统性能应避免嵌套。</li>
</ul>
</li>
</ul>
<h3 id="（2）中断重新使能的问题"><a href="#（2）中断重新使能的问题" class="headerlink" title="（2）中断重新使能的问题"></a>（2）中断重新使能的问题</h3><ul>
<li><p>当另外一个中断抢先当前中断时，如果程序员使用下边特殊的步骤来防止系统状态丢失 ，中断是可以嵌套：</p>
<ul>
<li>保存IRQ状态下的LR（ LR_IRQ ）</li>
<li>保存IRQ状态下的SPSR（SPSR_IRQ）</li>
</ul>
</li>
<li><p>当中断可重入时，在中断处理程序中使用“BL…”必须特别小心:</p>
<ul>
<li>如果第二个中断产生，BL调用的返回地址 (LR_irq) 可能被冲掉，子程序将错误的返回 – 导致无限循环!</li>
</ul>
</li>
<li><p>解决方法是在使用“BL…”之前改变模式来避免 LR_irq 被冲掉</p>
<ul>
<li>通常使用“System”模式 ( 这时 BL 使用 LR_usr)</li>
</ul>
</li>
<li><p>在处理程序结束，必须：</p>
<ul>
<li>切换回 IRQ 模式</li>
<li>禁止中断 (来避免在恢复SPSR_irq 到一个临时的寄存器中后它被冲掉).</li>
</ul>
</li>
</ul>
<h3 id="（3）软中断"><a href="#（3）软中断" class="headerlink" title="（3）软中断"></a>（3）软中断</h3><img src="https://cdn.megalomania.icu/images/06856245f71e71dc4b6e77753fe3e72c.png">

<h3 id="（4）SWI调用"><a href="#（4）SWI调用" class="headerlink" title="（4）SWI调用"></a>（4）SWI调用</h3><ul>
<li><p>汇编中, SWI 调用使用“SWI 中断号”实现：</p>
<ul>
<li><code>SWI 0x24</code></li>
</ul>
</li>
<li><p>小心在汇编中如果SWI 调用时处于Supervisor模式将会冲掉LR_svc.</p>
<ul>
<li>例如：在SWI处理程序中的二级调用</li>
<li>解决方法: 在SWI调用之前对LR_svc 压栈保护</li>
</ul>
</li>
<li><p>C 中, 使用关键词 “__swi” 来定义一个软中断函数</p>
</li>
</ul>
<h3 id="（5）存取SWI号"><a href="#（5）存取SWI号" class="headerlink" title="（5）存取SWI号"></a>（5）存取SWI号</h3><ul>
<li><p>SWI 指令按相应的格式译码：    </p>
<ul>
<li>ARM 态格式:</li>
</ul>
<img src="https://cdn.megalomania.icu/images/7389d5f54492c758094b9665351a626e.png">




</li>
</ul>
<ul>
<li><p>Thumb 态格式:</p>
  <img src="https://cdn.megalomania.icu/images/48c42dab1288ecb7a1cf6dc60cd1d132.png">

</li>
</ul>
<h3 id="（6）存取SWI参数"><a href="#（6）存取SWI参数" class="headerlink" title="（6）存取SWI参数"></a>（6）存取SWI参数</h3><ul>
<li>汇编中，存取调用者设置的寄存器即可.    <ul>
<li>在返回之前，修改寄存器的值，传回参数给调用者.</li>
</ul>
</li>
<li>传参数给C, 通常采用压栈的方法.    <ul>
<li>将参数压栈</li>
<li>给调用的函数传递一个指向这些参数的指针</li>
<li>也可以通过将参数值写回到适当的堆栈位置，将参数传回</li>
</ul>
</li>
</ul>
<h3 id="（7）复位"><a href="#（7）复位" class="headerlink" title="（7）复位"></a>（7）复位</h3><ul>
<li>Reset 处理程序执行的动作取决于不同的系统. 例如它可以:    <ul>
<li>设置异常向量</li>
<li>初始化存储器系统 (MMU/PU)</li>
<li>初始化所有需要的模式的堆栈和寄存器</li>
<li>初始化所有 C 所需的变量</li>
<li>初始化所有I/O设备</li>
<li>使能中断</li>
<li>改变处理器模式或/和状态</li>
<li>调用主应用程序</li>
</ul>
</li>
</ul>
<h3 id="（8）未定义指令"><a href="#（8）未定义指令" class="headerlink" title="（8）未定义指令"></a>（8）未定义指令</h3><ul>
<li><p>下列情况将引起未定义指令异常:、</p>
<ul>
<li>ARM 试图执行一真正的未定义指令</li>
<li>ARM 遇到一协处理器指令，可是系统中的协处理器硬件并不存在</li>
<li>ARM 遇到一协处理器指令，系统中协处理器硬件也存在，可是ARM 不是在超级用户模式(privileged mode)    <ul>
<li>例如：操作协处理器15(cp15) - ARM cache 控制器</li>
</ul>
</li>
</ul>
</li>
<li><p>解决方法:</p>
<ul>
<li>在处理程序中执行软协处理器仿真</li>
<li>禁止在非超级用户模式下操作</li>
<li>报告错误并退出</li>
</ul>
</li>
</ul>
<h3 id="（9）预取异常"><a href="#（9）预取异常" class="headerlink" title="（9）预取异常"></a>（9）预取异常</h3><ul>
<li><p>不论异常是发生在 ARM 还是Thumb 状态下，导致预取异常的指令地址在 lr-4 处.</p>
</li>
<li><p>处理方法取决于存储器管理策略</p>
<ul>
<li>有存储器管理的系统 (e.g. demand paged virtual memory)    <ul>
<li>修正问题 (e.g. enable correct memory page)</li>
<li>返回并重新执行预取异常的指令( SUBS pc,lr,#4 )</li>
</ul>
</li>
<li>没有存储器管理的系统    <ul>
<li>通常表示一个致命的错误</li>
<li>报告错误 (如果可能) 然后退出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（10）数据异常"><a href="#（10）数据异常" class="headerlink" title="（10）数据异常"></a>（10）数据异常</h3><ul>
<li><p>导致异常的指令的地址在 lr-8 处.</p>
</li>
<li><p>处理方法取决于存储器管理策略    </p>
<ul>
<li><p>有存储器管理的系统( demand-paged virtual memory)</p>
</li>
<li><p>如果使用了 MMU ，数据异常的地址在 MMU 的 “Fault Address” 寄存器中</p>
</li>
<li><p>修正问题(enable correct page of memory)</p>
</li>
<li><p>返回并重新执行数据异常的指令</p>
<p>  SUBS pc,lr,#8</p>
</li>
<li><p>没有存储器管理的系统</p>
<ul>
<li>通常表示一个致命的错误</li>
<li>报告错误 (如果可能) 然后退出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（11）异常返回地址"><a href="#（11）异常返回地址" class="headerlink" title="（11）异常返回地址"></a>（11）异常返回地址</h3><ul>
<li>ARM 状态:    <ul>
<li>在异常产生的时候内核设置 LR_mode = PC - 4.</li>
<li>处理程序需要调整 LR_mode (取决于是哪一个异常发生了)，以便返回到正确的地址</li>
</ul>
</li>
<li>Thumb 状态:    <ul>
<li>处理器根据发生的异常自动修改存在 LR_mode 中的地址</li>
<li>不论异常产生时的状态如何，处理器确保处理程序的ARM 返回指令能返回到正确的地址(和正确的状态)</li>
</ul>
</li>
</ul>
<h3 id="（12）从SWIs和未定义指令返回"><a href="#（12）从SWIs和未定义指令返回" class="headerlink" title="（12）从SWIs和未定义指令返回"></a>（12）从SWIs和未定义指令返回</h3><img src="https://cdn.megalomania.icu/images/7055bddc2574b7f987bb3d87d0dd969d.png">

<h3 id="（13）从FIQs和IRQs和预取异常返回"><a href="#（13）从FIQs和IRQs和预取异常返回" class="headerlink" title="（13）从FIQs和IRQs和预取异常返回"></a>（13）从FIQs和IRQs和预取异常返回</h3><img src="https://cdn.megalomania.icu/images/4c702fa4249bc320fdac8758fb4fcfbd.png">

<h3 id="（14）从数据异常返回"><a href="#（14）从数据异常返回" class="headerlink" title="（14）从数据异常返回"></a>（14）从数据异常返回</h3><img src="https://cdn.megalomania.icu/images/0a3c54f45c85b999c254bba6219f0a89.png">

<h3 id="（15）异常返回指令"><a href="#（15）异常返回指令" class="headerlink" title="（15）异常返回指令"></a>（15）异常返回指令</h3><ul>
<li><p>使用一数据处理指令：</p>
<ul>
<li><p>相应的指令取决于什么样的异常</p>
<pre><code>&gt; 设置CPSR, “S” bit
&gt; PC做为目的寄存器</code></pre>
</li>
</ul>
</li>
<li><p>在特权模式不仅仅更新PC，而且 拷贝SPSR 到 CPSR</p>
</li>
<li><p>从SWI 和 Undef异常返回</p>
<p><code>MOVS pc,lr</code></p>
</li>
<li><p>从FIQ, IRQ 和 预取异常(Prefect Abort)返回</p>
<p><code>SUBS pc,lr,#4</code></p>
</li>
<li><p>从数据异常( Data Abort)返回</p>
<p><code>SUBS pc,lr,#8</code></p>
</li>
<li><p>如果 LR之前被压栈的话使用LDM“ ^”</p>
<p><code>LDMFD sp!,&#123;pc&#125;^</code></p>
</li>
</ul>
<h2 id="14、-存储方式与存储器映射机制"><a href="#14、-存储方式与存储器映射机制" class="headerlink" title="14、 存储方式与存储器映射机制"></a>14、 存储方式与存储器映射机制</h2><ul>
<li>ARM处理器地址空间大小为4G字节，这些字节的单元地址是<strong>一个无符号的32位数值</strong>，其取值范围为0~(2^32)-1。各存储单元地址作为32位无符号数，可以进行常规的整数运算。</li>
<li>当程序正常执行时，<strong>每执行一条ARM指令，当前指令计数器加4个字节；每执行一条Thumb指令，当前指令计数器加2个字节</strong>。</li>
</ul>
<h3 id="（1）数据存储格式"><a href="#（1）数据存储格式" class="headerlink" title="（1）数据存储格式"></a>（1）数据存储格式</h3><ul>
<li>小端存储格式</li>
</ul>
<img src="https://cdn.megalomania.icu/images/f42600e01ba027ed9ccfc01e803ea0c8.png">

<ul>
<li>大端存储格式</li>
</ul>
<img src="https://cdn.megalomania.icu/images/0b969ad7b5aef8bdb018234720cda583.png">

<blockquote>
<p>ARM支持大小端格式存取数据</p>
</blockquote>
<h3 id="（2）非对齐存储器地址访问问题分析"><a href="#（2）非对齐存储器地址访问问题分析" class="headerlink" title="（2）非对齐存储器地址访问问题分析"></a>（2）非对齐存储器地址访问问题分析</h3><h4 id="1-非对齐的指令预取操作"><a href="#1-非对齐的指令预取操作" class="headerlink" title="1* 非对齐的指令预取操作"></a>1* 非对齐的指令预取操作</h4><ul>
<li>如果是在ARM状态下将一个非对齐地址写入PC，则<strong>数据在写入PC时数据的第0位和第1位被忽略，最终PC的bit[1：0]为0</strong>；</li>
<li>如果是在Thumb状态下将一个非对齐地址写入PC，则<strong>数据在写入PC时数据的第0位被忽略，最终PC的bit[0]为0</strong>。</li>
</ul>
<h4 id="2-非对齐地址内存的访问操作"><a href="#2-非对齐地址内存的访问操作" class="headerlink" title="2* 非对齐地址内存的访问操作"></a>2* 非对齐地址内存的访问操作</h4><ul>
<li>对于LOAD/STORE操作，系统定义了下面3种可能的结果：    <ul>
<li>执行结果不可预知；</li>
<li>忽略字单元地址低两位的值，即访问地址为字单元；</li>
<li>忽略半字单元最低位的值，即访问地址为半字单元。这种忽略是由存储系统自动实现的。</li>
</ul>
</li>
</ul>
<h2 id="15、ARM流水线技术分析"><a href="#15、ARM流水线技术分析" class="headerlink" title="15、ARM流水线技术分析"></a>15、ARM流水线技术分析</h2><h3 id="（1）ARM7流水线技术"><a href="#（1）ARM7流水线技术" class="headerlink" title="（1）ARM7流水线技术"></a>（1）ARM7流水线技术</h3><ul>
<li><p>为增加处理器指令流的速度，ARM7 系列使用3级流水线.</p>
<ul>
<li>允许多个操作同时处理，比逐条指令执行要快。<img src="https://cdn.megalomania.icu/images/0a9b2bff24dfd6755ea586b51a967662.png">
</li>
</ul>
</li>
<li><p>PC指向正被取指的指令，而非正在执行的指令</p>
</li>
<li><p>最佳流水线</p>
<img src="https://cdn.megalomania.icu/images/e46322dede506b7bcca8d7122b8ea030.png">

</li>
</ul>
<h3 id="（2）ARM9TDMI流水线"><a href="#（2）ARM9TDMI流水线" class="headerlink" title="（2）ARM9TDMI流水线"></a>（2）ARM9TDMI流水线</h3><ul>
<li><p>与ARM7的区别</p>
<img src="https://cdn.megalomania.icu/images/089de0568dc393779bd6db6b81e67b97.png">
</li>
<li><p>最佳流水线</p>
<img src="https://cdn.megalomania.icu/images/25113639859bc64d1da56ad72cbaa375.png">
</li>
<li><p>LDR互锁</p>
<ul>
<li>LDR指令之后立即跟一条数据操作指令，由于使用了相同的寄存器，将会导致互锁 。</li>
</ul>
</li>
<li><p>LDM互锁</p>
<ul>
<li>在LDM期间，有并行的存储器访问和回写周期</li>
</ul>
</li>
</ul>
<h1 id="三、ARM指令集寻址方式"><a href="#三、ARM指令集寻址方式" class="headerlink" title="三、ARM指令集寻址方式"></a>三、ARM指令集寻址方式</h1><h2 id="1、ARM指令的编码格式"><a href="#1、ARM指令的编码格式" class="headerlink" title="1、ARM指令的编码格式"></a>1、ARM指令的编码格式</h2><h3 id="（1）一般编码格式"><a href="#（1）一般编码格式" class="headerlink" title="（1）一般编码格式"></a>（1）一般编码格式</h3><ul>
<li>每条ARM指令占有4个字节，其指令长度为32位<br>![89de4100fc42de747ab60fd71b202ef0.png](/嵌入式系统与组成原理—提纲/89de4100fc42de747ab60fd71b202ef0.png %}</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>位置</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cond</td>
<td>bit[31:28]</td>
<td>指令执行的条件码</td>
</tr>
<tr>
<td>type</td>
<td>bit[27:26]</td>
<td>指令类型码</td>
</tr>
<tr>
<td>I</td>
<td>bit[25]</td>
<td>第二操作数是否是立即数</td>
</tr>
<tr>
<td>opcode</td>
<td>bit[24:21]</td>
<td>指令操作码</td>
</tr>
<tr>
<td>S</td>
<td>bit[20]</td>
<td>决定指令的操作结果是否影响CPSR</td>
</tr>
<tr>
<td>Rn</td>
<td>bit[19:16]</td>
<td>包含第一个操作数的寄存器编码</td>
</tr>
<tr>
<td>Rd</td>
<td>bit[15:12]</td>
<td>目标寄存器编码</td>
</tr>
<tr>
<td>Operand2</td>
<td>bit[11:0]</td>
<td>指令第二个操作数</td>
</tr>
</tbody></table>
<ul>
<li>ARM汇编指令语法格式：</li>
</ul>
<p><code>&lt;opcode&gt;&#123;&lt;cond&gt;&#125;&#123;S&#125;&lt;Rd&gt;,&lt;Rn&gt;,&lt;operand2&gt;</code></p>
<h3 id="（2）指令条件码"><a href="#（2）指令条件码" class="headerlink" title="（2）指令条件码"></a>（2）指令条件码</h3><table>
<thead>
<tr>
<th>二进制码</th>
<th>指令</th>
<th>意义</th>
<th>条件</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>EQ</td>
<td>相等</td>
<td>Z=1</td>
</tr>
<tr>
<td>0001</td>
<td>NE</td>
<td>不相等</td>
<td>Z=0</td>
</tr>
<tr>
<td>0010</td>
<td>CS/HS</td>
<td>无符号大于等于</td>
<td>C=1</td>
</tr>
<tr>
<td>0011</td>
<td>CC/LO</td>
<td>无等号小于</td>
<td>C=0</td>
</tr>
<tr>
<td>0100</td>
<td>MI</td>
<td>负数</td>
<td>N=1</td>
</tr>
<tr>
<td>0101</td>
<td>PL</td>
<td>非负数</td>
<td>N=0</td>
</tr>
<tr>
<td>0110</td>
<td>VS</td>
<td>上溢出</td>
<td>V=1</td>
</tr>
<tr>
<td>0111</td>
<td>VC</td>
<td>没有上溢出</td>
<td>V=0</td>
</tr>
<tr>
<td>1000</td>
<td>HI</td>
<td>无符号数大于</td>
<td>C=1且Z=0</td>
</tr>
<tr>
<td>1001</td>
<td>LS</td>
<td>无符号数小于等于</td>
<td>C=0或Z=1</td>
</tr>
<tr>
<td>1010</td>
<td>GE</td>
<td>有符号数大于等于</td>
<td>N=1且V=1或N=0且V=0</td>
</tr>
<tr>
<td>1011</td>
<td>LT</td>
<td>有符号数小于</td>
<td>N=1且V=0或N=0且V=1</td>
</tr>
<tr>
<td>1100</td>
<td>GT</td>
<td>有符号数大于</td>
<td>Z=0且N=V</td>
</tr>
<tr>
<td>1101</td>
<td>LE</td>
<td>有符号数小于等于</td>
<td>Z=1或N!=V</td>
</tr>
<tr>
<td>1110</td>
<td>AL</td>
<td>无条件执行</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2、数据处理指令寻址方式"><a href="#2、数据处理指令寻址方式" class="headerlink" title="2、数据处理指令寻址方式"></a>2、数据处理指令寻址方式</h2><h3 id="（1）数据处理指令第2操作数的构成方式"><a href="#（1）数据处理指令第2操作数的构成方式" class="headerlink" title="（1）数据处理指令第2操作数的构成方式"></a>（1）数据处理指令第2操作数的构成方式</h3><h4 id="1-立即数方式"><a href="#1-立即数方式" class="headerlink" title="1* 立即数方式"></a>1* 立即数方式</h4><ul>
<li><p>每个立即数由一个8位的常数进行32位循环右移偶数位得到，其中循环右移的位数由一个4位二进制的两倍表示。即：</p>
<p><code>&lt;immediate&gt;=immed_8进行32位循环右移（2* rotate_4）位</code></p>
</li>
</ul>
<blockquote>
<p>ARM处理器中，立即数必须是对应8位位图格式，即立即数是由一个8bit的常数在16位或32位的寄存器中循环移动（向左或向右都可以）偶数位得到的。合法的立即数必须能够找到得到它的那个常数，否则这个立即数就是非法的。</p>
</blockquote>
<img src="https://cdn.megalomania.icu/images/be492bb4e5ca058e29674441c415c992.png">

<img src="https://cdn.megalomania.icu/images/12bbe55aeedd66ed93d382ce34d45666.png">

<h4 id="2-寄存器方式"><a href="#2-寄存器方式" class="headerlink" title="2* 寄存器方式"></a>2* 寄存器方式</h4><ul>
<li>操作数即为寄存器的数值，如：</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">R3</span>,<span class="built_in">R2</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-寄存器移位方式"><a href="#3-寄存器移位方式" class="headerlink" title="3*寄存器移位方式"></a>3*寄存器移位方式</h4><ul>
<li>寄存器移位方式    <ul>
<li>操作数为寄存器的数值做相应的移位而得到。在ARM指令中移位操作包括逻辑左移、逻辑右移、算术左移、算术右移、循环右移和带扩展的循环右移<img src="https://cdn.megalomania.icu/images/9e8d6de1c674f2097b99c8ca0740b5ce.png">

</li>
</ul>
</li>
</ul>
<h3 id="（2）具体寻址类型"><a href="#（2）具体寻址类型" class="headerlink" title="（2）具体寻址类型"></a>（2）具体寻址类型</h3><h4 id="1-第二操作数为立即数"><a href="#1-第二操作数为立即数" class="headerlink" title="1* 第二操作数为立即数"></a>1* 第二操作数为立即数</h4><ul>
<li>汇编语法格式：<code>#&lt;immediate&gt;</code><img src="https://cdn.megalomania.icu/images/b5d9b0c5b4f9cc8de0e4c6600613f9e7.png">

</li>
</ul>
<blockquote>
<p>I位bits[25] 设置为1</p>
</blockquote>
<p>eg.</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MOV</span> R<span class="number">0</span>, <span class="number">0</span>xFC<span class="number">0</span>           ;R<span class="number">0</span>←<span class="number">0</span>xFC<span class="number">0</span></span><br><span class="line"><span class="attribute">ADD</span>	R<span class="number">0</span>，R<span class="number">0</span>，＃<span class="number">1</span>		 ;R<span class="number">0</span>←R<span class="number">0</span>＋<span class="number">1</span></span><br><span class="line"><span class="attribute">ADD</span>	R<span class="number">0</span>，R<span class="number">0</span>，＃<span class="number">0</span>x<span class="number">3</span>f	   ;R<span class="number">0</span>←R<span class="number">0</span>＋<span class="number">0</span>x<span class="number">3</span>f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在以上三条指令中，第二个源操作数即为立即数，要求以“＃”为前缀，对于以十六进制表示的立即数，还要求在“＃”后加上“0x”。</p>
</blockquote>
<h4 id="2-第二操作数为寄存器"><a href="#2-第二操作数为寄存器" class="headerlink" title="2* 第二操作数为寄存器"></a>2* 第二操作数为寄存器</h4><ul>
<li><p>汇编语法格式：<code>&lt;Rm&gt;</code></p>
<img src="https://cdn.megalomania.icu/images/1cc4bd59f60f90a0c7c88e45240d0fea.png">
</li>
<li><p>I位bits[25] 设置为0</p>
</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ADD</span> R<span class="number">0</span>, R<span class="number">1</span>, R<span class="number">2</span>   ; R<span class="number">0</span>←R<span class="number">1</span> + R<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-第二操作数为寄存器移位方式，且移位的位数为一个5位的立即数"><a href="#3-第二操作数为寄存器移位方式，且移位的位数为一个5位的立即数" class="headerlink" title="3* 第二操作数为寄存器移位方式，且移位的位数为一个5位的立即数"></a>3* 第二操作数为寄存器移位方式，且移位的位数为一个5位的立即数</h4><ul>
<li>汇编语法格式：<code>&lt;Rm&gt;,&lt;shift&gt; #&lt;shift_imm&gt;</code><img src="https://cdn.megalomania.icu/images/bd7b89fe4b0f51cf4dce844a6b2e5564.png">

</li>
</ul>
<h4 id="4-第二操作数为寄存器移位方式，且移位数值放在寄存器中"><a href="#4-第二操作数为寄存器移位方式，且移位数值放在寄存器中" class="headerlink" title="4* 第二操作数为寄存器移位方式，且移位数值放在寄存器中"></a>4* 第二操作数为寄存器移位方式，且移位数值放在寄存器中</h4><ul>
<li>汇编语法格式：<code>&lt;Rm&gt;，&lt;shift&gt; &lt;Rs&gt;</code><img src="https://cdn.megalomania.icu/images/40b8d91fdfc2b4dcd3863d7789723d43.png">

</li>
</ul>
<h4 id="5-第二操作数为寄存器进行RRX移位得到"><a href="#5-第二操作数为寄存器进行RRX移位得到" class="headerlink" title="5* 第二操作数为寄存器进行RRX移位得到"></a>5* 第二操作数为寄存器进行RRX移位得到</h4><ul>
<li><p>汇编语法格式：<code>&lt;Rm&gt;，RRX</code></p>
<img src="https://cdn.megalomania.icu/images/4433f1193ba575a2d4e109771c6226cf.png">

<img src="https://cdn.megalomania.icu/images/365b26fac29a5f15f7605a55c24ae8ae.png">

</li>
</ul>
<h3 id="（3）寄存器寻址"><a href="#（3）寄存器寻址" class="headerlink" title="（3）寄存器寻址"></a>（3）寄存器寻址</h3><ul>
<li>寄存器寻址    </li>
<li>利用寄存器中的数值作为操作数，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式。</li>
</ul>
<h3 id="（4）第二操作数为寄存器"><a href="#（4）第二操作数为寄存器" class="headerlink" title="（4）第二操作数为寄存器"></a>（4）第二操作数为寄存器</h3><ul>
<li>在ARM指令的数据处理指令中参与操作的二操作数为寄存器型时，在执行寄存器寻址操作时，可以选择是否对第二操作数进行移位，即<code>Rm，&#123;&lt;shift&gt;&#125;</code>，其中Rm称为第二操作数寄存器，<code>&lt;shift&gt;</code>用来指定移位类型（LSL，LSR，ASL，ASR，ROR或RRX）和移位位数。移位位数可以是5位立即数（#&lt;#shift&gt;）或寄存器（Rs）。在指令执行时将移位后的内容作为第二操作数参与运算。例如指令：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ADD</span> R<span class="number">3</span>，R<span class="number">2</span>，R<span class="number">1</span>，LSR  #<span class="number">2</span>    ;R<span class="number">3</span>←R<span class="number">2</span> + R<span class="number">1</span>÷<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="（5）Load-Store指令寻址"><a href="#（5）Load-Store指令寻址" class="headerlink" title="（5）Load/Store指令寻址"></a>（5）Load/Store指令寻址</h3><ul>
<li>Load/Store指令是对内存进行存储/加载数据操作的指令，根据访问的数据格式的不同，将这类指令的寻址分为<strong>字、无符号字节的Load/Store指令寻址</strong>和<strong>半字、有符号字节Load/Store指令寻址两大类</strong>。</li>
</ul>
<h4 id="1-寄存器间接寻址"><a href="#1-寄存器间接寻址" class="headerlink" title="1* 寄存器间接寻址"></a>1* 寄存器间接寻址</h4><ul>
<li>寄存器间接寻址就是以寄存器中的值作为操作数的地址，而操作数本身存放在存储器中。例如以下指令：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">LDR</span>	 R<span class="number">0</span>，[R<span class="number">1</span>] 		;R<span class="number">0</span> ←[R<span class="number">1</span>] </span><br><span class="line"><span class="attribute">STR</span>	 R<span class="number">0</span>，[R<span class="number">1</span>] 		;[R<span class="number">1</span>]← R<span class="number">0</span> </span><br></pre></td></tr></table></figure>
<h3 id="（6）基址加变址寻址"><a href="#（6）基址加变址寻址" class="headerlink" title="（6）基址加变址寻址"></a>（6）基址加变址寻址</h3><ul>
<li>基址变址寻址就是将寄存器（该寄存器一般称作基址寄存器）的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。变址寻址方式常用于访问某基地址附近的地址单元。    <ul>
<li>前变址法：基地址寄存器中的值和地址偏移量先作加减运算，生成的操作数作为内存访问的地址。</li>
<li>后变址法：将基地址寄存器中的值直接作为内存访问的地址进行操作，内存访问完毕后基地址寄存器中的值和地址偏移量作加减运算，并更新基地址寄存器。</li>
</ul>
</li>
</ul>
<h3 id="（7）字、无符号字节寻址"><a href="#（7）字、无符号字节寻址" class="headerlink" title="（7）字、无符号字节寻址"></a>（7）字、无符号字节寻址</h3><ul>
<li>汇编指令语法格式为：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">LDR </span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="template-variable">&#123;B&#125;</span><span class="template-variable">&#123;T&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">Rd</span>&gt;</span>,<span class="tag">&lt;<span class="name">addressing_mode</span>&gt;</span></span></span><br><span class="line"><span class="xml">STR </span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="template-variable">&#123;B&#125;</span><span class="template-variable">&#123;T&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">Rd</span>&gt;</span>,<span class="tag">&lt;<span class="name">addressing_mode</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/f669609fdb8b31824940ccc875cc16cc.png">

<img src="https://cdn.megalomania.icu/images/0a6a40c9950f58ea73683fa8c9824687.png">

<h4 id="1-Addressing-mode中的偏移量为立即数"><a href="#1-Addressing-mode中的偏移量为立即数" class="headerlink" title="1* Addressing_mode中的偏移量为立即数"></a>1* Addressing_mode中的偏移量为立即数</h4><ul>
<li>前变址不回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;，#+/-&lt;immed_offset&gt;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;，#+/-&lt;immed_offset&gt;]</span>！</span><br></pre></td></tr></table></figure>
<ul>
<li>后变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;]</span>，#+/-&lt;immed_offset&gt;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/6ee0ff0cd1e5e2b381e6db9e503b0562.png">

<table>
<thead>
<tr>
<th>W</th>
<th>P</th>
<th>汇编语法格式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>[<Rn>，#+/-<immed_offset>]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>[<Rn>]，#+/-<immed_offset></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>[<Rn>，#+/-<immed_offset>]!</td>
</tr>
</tbody></table>
<h4 id="2-Addressing-mode中的偏移量为寄存器的值"><a href="#2-Addressing-mode中的偏移量为寄存器的值" class="headerlink" title="2* Addressing_mode中的偏移量为寄存器的值"></a>2* Addressing_mode中的偏移量为寄存器的值</h4><ul>
<li>前变址不回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;，+/-&lt;Rm&gt;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;，+/-&lt;Rm&gt;]</span>！</span><br></pre></td></tr></table></figure>
<ul>
<li>后变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;]</span>，+/-&lt;Rm&gt;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/f440793da4ce61807f0c90d2b4c60f13.png">

<table>
<thead>
<tr>
<th>W</th>
<th>P</th>
<th>汇编语法格式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>[<Rn>，+/-<Rm>]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>[<Rn>]，+/-<Rm></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>[<Rn>，+/-<Rm>]!</td>
</tr>
</tbody></table>
<h4 id="偏移量通过寄存器移位得到"><a href="#偏移量通过寄存器移位得到" class="headerlink" title="偏移量通过寄存器移位得到"></a>偏移量通过寄存器移位得到</h4><ul>
<li>前变址不回写形式：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="params">&lt;Rn&gt;</span>，+/-<span class="params">&lt;Rm&gt;</span>，<span class="params">&lt;shift&gt;</span><span class="meta">#shift_amount]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前变址回写形式：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="params">&lt;Rn&gt;</span>，+/-<span class="params">&lt;Rm&gt;</span>，<span class="params">&lt;shift&gt;</span><span class="meta">#shift_amount]！</span></span><br></pre></td></tr></table></figure>
<ul>
<li>后变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;]</span>，+/-&lt;Rm&gt;，&lt;shift&gt;#shift_amount</span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/7634c590cf8d1ba1a6d4e290749ad537.png">

<table>
<thead>
<tr>
<th>W</th>
<th>P</th>
<th>汇编语法格式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>[<Rn>，+/-<Rm>，<shift>#shift_amount]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>[<Rn>]，+/-<Rm>，<shift>#shift_amount</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>[<Rn>，+/-<Rm>，<shift>#shift_amount]!</td>
</tr>
</tbody></table>
<h3 id="（8）半字、有符号字节寻址"><a href="#（8）半字、有符号字节寻址" class="headerlink" title="（8）半字、有符号字节寻址"></a>（8）半字、有符号字节寻址</h3><ul>
<li><p>这类指令可用来加载有符号字节、加载有符号半字、加载/存储无符号半字。</p>
</li>
<li><p>Load/Store指令对半字、有符号字节操作指令编码格式如下：</p>
<img src="https://cdn.megalomania.icu/images/5765315414c31541336581706e9633a2.png">
</li>
<li><p>加载有符号字节到寄存器：</p>
</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">LDR </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;SB <span class="params">&lt;Rd&gt;</span>,<span class="params">&lt;addressing_mode&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>加载有符号半字到寄存器：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">LDR </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;SH <span class="params">&lt;Rd&gt;</span>,<span class="params">&lt;addressing_mode&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>加载无符号半字到寄存器：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">LDR </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;H  <span class="params">&lt;Rd&gt;</span>,<span class="params">&lt;addressing_mode&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>存储无符号半字到内存：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">STR </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;H  <span class="params">&lt;Rd&gt;</span>,<span class="params">&lt;addressing_mode&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-Addressing-mode中的偏移量为立即数-1"><a href="#1-Addressing-mode中的偏移量为立即数-1" class="headerlink" title="1* Addressing_mode中的偏移量为立即数"></a>1* Addressing_mode中的偏移量为立即数</h4><ul>
<li>前变址不回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;，#+/-&lt;immed_offset8&gt;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;，#+/-&lt;immed_offset8&gt;]</span>！</span><br></pre></td></tr></table></figure>
<ul>
<li>后变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;]</span>，#+/-&lt;immed_offset8&gt;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/d5782364cdf318299742c9ae03eeda90.png">

<table>
<thead>
<tr>
<th>W</th>
<th>P</th>
<th>汇编语法格式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>[<Rn>，#+/-<immed_offset8>]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>[<Rn>]，#+/-<immed_offset8></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>[<Rn>，#+/-<immed_offset8>]!</td>
</tr>
</tbody></table>
<h4 id="2-Addressing-mode中的偏移量为寄存器的值-1"><a href="#2-Addressing-mode中的偏移量为寄存器的值-1" class="headerlink" title="2* Addressing_mode中的偏移量为寄存器的值"></a>2* Addressing_mode中的偏移量为寄存器的值</h4><ul>
<li>前变址不回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;，+/-&lt;Rm&gt;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;，+/-&lt; Rm &gt;]</span>！</span><br></pre></td></tr></table></figure>
<ul>
<li>后变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;]</span>，+/-&lt; Rm &gt;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/a1611f819355dc875bd1fa50be7acf16.png">

<table>
<thead>
<tr>
<th>W</th>
<th>P</th>
<th>汇编语法格式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>[<Rn>，+/-<Rm>]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>[<Rn>]，+/-&lt; Rm &gt;</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>[<Rn>，+/-&lt; Rm &gt;]!</td>
</tr>
</tbody></table>
<h3 id="（9）批量Load-Store指令寻址方式"><a href="#（9）批量Load-Store指令寻址方式" class="headerlink" title="（9）批量Load/Store指令寻址方式"></a>（9）批量Load/Store指令寻址方式</h3><ul>
<li>ARM指令系统提供了批量Load/Store指令寻址方式，即通常所说的多寄存器寻址，也就是一次可以传送几个寄存器的值，允许一条指令最多传送16个寄存器。</li>
</ul>
<h4 id="1-编码格式"><a href="#1-编码格式" class="headerlink" title="1* 编码格式"></a>1* 编码格式</h4><ul>
<li>批量加载：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">LDM </span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">addr_mode</span>&gt;</span> <span class="tag">&lt;<span class="name">Rn</span>&gt;</span> </span><span class="template-variable">&#123;!&#125;</span><span class="xml">, <span class="tag">&lt;<span class="name">register</span>&gt;</span></span><span class="template-variable">&#123;^&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>批量存储：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">STM </span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">addr_mode</span>&gt;</span> <span class="tag">&lt;<span class="name">Rn</span>&gt;</span> </span><span class="template-variable">&#123;!&#125;</span><span class="xml">, <span class="tag">&lt;<span class="name">register</span>&gt;</span></span><span class="template-variable">&#123;^&#125;</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/dc3de4fc197aa62bc0341851cc217d63.png">

<ul>
<li>register_list表示要加载或存储的寄存器列表，bit[15:0]可以表示16个寄存器，如果某位为1，则该位的位置作为寄存器的编号，此寄存器参预加载或存储。</li>
<li>S用于恢复CPSR和强制用户位。当程序计数器PC包含在LDM指令的register_list中，且S为1时，则当前模式的SPSR被拷贝到CPSR中，使处理器的程序返回和状态的恢复成为一个原子操作。如果register_list中不包含程序计数器PC，S为1则加载或存储的是用户模式下的寄存器组。</li>
</ul>
<blockquote>
<p>注意事项：</p>
<ul>
<li>指令中寄存器和连续内存地址单元的对应关系：</li>
<li>编号低的寄存器对应内存低地址单元，编号高的寄存器对应内存高地址单元。</li>
</ul>
</blockquote>
<h4 id="2-内存操作"><a href="#2-内存操作" class="headerlink" title="2* 内存操作"></a>2* 内存操作</h4><ul>
<li><p>后增IA (Increment After) ：每次数据传送后地址加4；</p>
</li>
<li><p>先增IB (Increment Before) ：每次数据传送前地址加4 ；</p>
</li>
<li><p>后减DA (Decrement After) ：每次数据传送后地址减4 ；</p>
</li>
<li><p>先减DB (Decrement Before) ：每次数据传送前地址减4 ；</p>
</li>
<li><p>它们与指令编码中P、U的对应关如下表所示    </p>
<ul>
<li>LDM/STM的地址变化方式</li>
</ul>
<table>
<thead>
<tr>
<th>addr_mode</th>
<th>P</th>
<th>U</th>
</tr>
</thead>
<tbody><tr>
<td>D A</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>I A</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>D B</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>I B</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
</li>
</ul>
<img src="https://cdn.megalomania.icu/images/209c22ec4bca761ffc4e1ccf4186e14f.png">

<h4 id="3-堆栈操作"><a href="#3-堆栈操作" class="headerlink" title="3* 堆栈操作"></a>3* 堆栈操作</h4><ul>
<li>堆栈是一种数据结构</li>
<li>先进先出</li>
<li>使用一个堆栈指针的专用寄存器只是当前位置    </li>
<li>ARM 中是R13</li>
<li><strong>根据堆栈指针的位置可以分为</strong>：    <ul>
<li>满堆栈（Full Stack）：    </li>
<li>当堆栈指针指向最后压入堆栈的数据时；</li>
<li>空堆栈（Empty Stack）：    <ul>
<li>当堆栈指针指向下一个将要放入数据的空位置时；</li>
</ul>
</li>
</ul>
</li>
<li><strong>根据堆栈的生成方式，又可以分为递增堆栈和递减堆栈</strong>：    </li>
<li>递增堆栈（Ascending Stack） ：    <ul>
<li>当堆栈由低地址向高地址生成时；</li>
<li>递减堆栈（Decending Stack） ：    <ul>
<li>当堆栈由高地址向低地址生成时；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-块拷贝与栈操作的对应关系"><a href="#4-块拷贝与栈操作的对应关系" class="headerlink" title="4* 块拷贝与栈操作的对应关系"></a>4* 块拷贝与栈操作的对应关系</h4><img src="https://cdn.megalomania.icu/images/2b93e4faa9c07b751567db82537eb141.png">

<h3 id="（7）协处理器指令寻址方式"><a href="#（7）协处理器指令寻址方式" class="headerlink" title="（7）协处理器指令寻址方式"></a>（7）协处理器指令寻址方式</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">opcode</span>&gt;</span></span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="template-variable">&#123;L&#125;</span><span class="xml"> <span class="tag">&lt;<span class="name">coproc</span>&gt;</span>，<span class="tag">&lt;<span class="name">CRd</span>&gt;</span>,<span class="tag">&lt;<span class="name">addressing_mode</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>opcode为指令操作码；</li>
<li>coproc为协处理器名称；</li>
<li>addressing_mode为指令寻址模式。</li>
</ul>
</li>
</ul>
<h4 id="1-内存地址索引格式"><a href="#1-内存地址索引格式" class="headerlink" title="1* 内存地址索引格式"></a>1* 内存地址索引格式</h4><img src="https://cdn.megalomania.icu/images/f794660439842458450ed05982d076c7.png">

<ul>
<li>前变址不回写形式：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="tag">&lt;<span class="name">Rn</span>&gt;</span>，#+/-<span class="tag">&lt;<span class="name">imm_offset8</span>&gt;</span>* 4]</span><br></pre></td></tr></table></figure>
<ul>
<li>前变址回写形式：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="tag">&lt;<span class="name">Rn</span>&gt;</span>，#+/-<span class="tag">&lt;<span class="name">imm_offset8</span>&gt;</span>* 4]！</span><br></pre></td></tr></table></figure>
<ul>
<li>后变址回写形式：</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;]</span>，#+/-&lt;imm_offset8&gt;* <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="2-内存地址非索引格式"><a href="#2-内存地址非索引格式" class="headerlink" title="2* 内存地址非索引格式"></a>2* 内存地址非索引格式</h4><ul>
<li>这种指令寻址汇编语法格式为</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;Rn&gt;]</span>，&lt;user-define&gt;	</span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/e2b0b2fbc1bc0fdac6e9384afb7ef3b9.png">

<h1 id="四、ARM指令集系统"><a href="#四、ARM指令集系统" class="headerlink" title="四、ARM指令集系统"></a>四、ARM指令集系统</h1><h2 id="1、数据处理指令"><a href="#1、数据处理指令" class="headerlink" title="1、数据处理指令"></a>1、数据处理指令</h2><h3 id="（1）基本数据处理指令"><a href="#（1）基本数据处理指令" class="headerlink" title="（1）基本数据处理指令"></a>（1）基本数据处理指令</h3><ul>
<li>ARM基本的数据处理指可以分为4类：数据传送指令、算术运算指令、逻辑运算指令和比较指令。</li>
<li>ARM基本的数据处理指令汇编指令语法格式：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">opcode</span>&gt;</span></span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">Rd</span>&gt;</span>,<span class="tag">&lt;<span class="name">Rn</span>&gt;</span>,<span class="tag">&lt;<span class="name">operand2</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/3e393384c7605e18637bf2dba9d0fc17.png">

<img src="https://cdn.megalomania.icu/images/bd9c9f1705bf265f1d83c39028ec089a.png">

<h4 id="1-数据传输指令"><a href="#1-数据传输指令" class="headerlink" title="1* 数据传输指令"></a>1* 数据传输指令</h4><h5 id="1-MOV指令"><a href="#1-MOV指令" class="headerlink" title="1. MOV指令"></a>1. MOV指令</h5><ul>
<li>MOV指令的汇编语法格式为</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">MOV</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将第二操作数operand2表示的数据传送到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果或移位情况更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="2-MVN指令"><a href="#2-MVN指令" class="headerlink" title="2. MVN指令"></a>2. MVN指令</h5><ul>
<li>MVN指令的汇编语法格式为</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">MVN</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将第二操作数operand2表示的数据<strong>按位取反</strong>后传送到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果或移位情况更新CPSR中的相应条件标志位。</li>
</ul>
<h4 id="2-算数运算指令"><a href="#2-算数运算指令" class="headerlink" title="2* 算数运算指令"></a>2* 算数运算指令</h4><h5 id="1-ADD加法指令"><a href="#1-ADD加法指令" class="headerlink" title="1. ADD加法指令"></a>1. ADD加法指令</h5><ul>
<li>ADD加法指令的汇编语法格式为</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash">&#123;cond&#125;&#123;S&#125;  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ADD指令将operand2表示的数据与寄存器Rn中的值相加，并把结果传送到目标寄存器<code>&lt;Rd&gt;</code>中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="2-ADC带C标志位的加法指令"><a href="#2-ADC带C标志位的加法指令" class="headerlink" title="2. ADC带C标志位的加法指令"></a>2. ADC带C标志位的加法指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">ADC</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：ADC带C标志位的加法指令将operand2表示的数据与寄存器Rn中的值相加，再加上CPSR中的C条件标志位的值，并把结果传送到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。该指令可以实现两个高于32位的数据相加运算。</li>
</ul>
<h5 id="3-SUB减法指令"><a href="#3-SUB减法指令" class="headerlink" title="3. SUB减法指令"></a>3. SUB减法指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">SUB</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：SUB指令从寄存器Rn中减去operand2表示的数值，并把结果传送到目标寄存器<code>&lt;Rd&gt;</code>中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<blockquote>
<p>注意事项：当指令包含后缀“S”时，如果减法运算有借位，则C=0，否则C=1。</p>
</blockquote>
<h5 id="4-SBC带C标志位的减法指令"><a href="#4-SBC带C标志位的减法指令" class="headerlink" title="4. SBC带C标志位的减法指令"></a>4. SBC带C标志位的减法指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">SBC</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SBC指令从寄存器<code>&lt;Rn&gt;</code>中减去operand2表示的数值，再减去寄存器CPSR中C条件标志位的反码，并把结果传送到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。该指令可以实现两个高于32位的数据相减运算。</li>
</ul>
<h5 id="5-RSB逆向减法指令"><a href="#5-RSB逆向减法指令" class="headerlink" title="5. RSB逆向减法指令"></a>5. RSB逆向减法指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">RSB</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：RSB指令从第2操作数operand2表示的数值中减去寄存器Rn 值，并把结果传送到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="6-RSC带C标志位的逆向减法指令"><a href="#6-RSC带C标志位的逆向减法指令" class="headerlink" title="6. RSC带C标志位的逆向减法指令"></a>6. RSC带C标志位的逆向减法指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">RSC</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd，Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：RSC指令从operand2表示的数值中减去寄存器Rn 值，再减去寄存器CPSR中 C条件标志位的反码，并把结果传送到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h4 id="3-逻辑运算指令"><a href="#3-逻辑运算指令" class="headerlink" title="3* 逻辑运算指令"></a>3* 逻辑运算指令</h4><h5 id="1-AND与逻辑运算指令"><a href="#1-AND与逻辑运算指令" class="headerlink" title="1. AND与逻辑运算指令"></a>1. AND与逻辑运算指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">AND</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：AND指令将operand2表示的数值与寄存器Rn 的值按位做逻辑与操作，并把结果保存到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="2-ORR或逻辑运算指令"><a href="#2-ORR或逻辑运算指令" class="headerlink" title="2. ORR或逻辑运算指令"></a>2. ORR或逻辑运算指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">ORR</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：ORR指令将operand2表示的数值与寄存器Rn的值按位做逻辑或操作，并把结果保存到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="3-EOR异或逻辑运算指令"><a href="#3-EOR异或逻辑运算指令" class="headerlink" title="3. EOR异或逻辑运算指令"></a>3. EOR异或逻辑运算指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">EOR</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：EOR指令将operand2表示的数值与寄存器Rn的值按位做逻辑异或操作，并把结果保存到目标寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。EOR指令可用于将寄存器中某些位的值取反。</li>
</ul>
<h5 id="4-BIC清除逻辑运算指令"><a href="#4-BIC清除逻辑运算指令" class="headerlink" title="4. BIC清除逻辑运算指令"></a>4. BIC清除逻辑运算指令</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">BIC</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  Rd, Rn, operand2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：BIC指令将寄存器Rn的值与operand2表示的数值的反码按位做逻辑与操作，并把结果保存到目标寄存器Rd中</li>
</ul>
<h4 id="4-比较指令"><a href="#4-比较指令" class="headerlink" title="4* 比较指令"></a>4* 比较指令</h4><ul>
<li>比较指令没有目标寄存器，只用作更新条件标志位，不保存运算结果，指令后缀无需加“S”。在程序设计中，根据操作的结果更新CPSR中相应的条件标志位，后面的指令就可以根据CPSR中相应的条件标志位来判断是否执行。</li>
</ul>
<h5 id="1-CMP相减比较指令"><a href="#1-CMP相减比较指令" class="headerlink" title="1. CMP相减比较指令"></a>1. CMP相减比较指令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CMP</span>&#123;cond&#125;  Rn, operand<span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：CMP指令将寄存器Rn的值减去operand2表示的数值，根据操作结果和寄存器移位情况更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="2-CMN负数比较指令"><a href="#2-CMN负数比较指令" class="headerlink" title="2. CMN负数比较指令"></a>2. CMN负数比较指令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CMN</span>&#123;cond&#125;  Rn, operand<span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：CMN指令将寄存器Rn的值加上operand2表示的数值，根据操作结果和寄存器移位情况更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="3-TST位测试指令"><a href="#3-TST位测试指令" class="headerlink" title="3. TST位测试指令"></a>3. TST位测试指令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">TST</span>&#123;cond&#125;  Rn, operand<span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：TST指令将寄存器Rn的值与operand2表示的数值按位作逻辑“与”操作，根据操作结果和寄存器移位情况更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="4-TEQ相等测试指令"><a href="#4-TEQ相等测试指令" class="headerlink" title="4. TEQ相等测试指令"></a>4. TEQ相等测试指令</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">TEQ</span>&#123;cond&#125;  Rn, operand<span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：TEQ指令将寄存器Rn的值与operand2表示的数值按位作逻辑“异或”操作，根据操作结果和寄存器移位情况更新CPSR中的相应条件标志位。</li>
</ul>
<h3 id="（2）乘法指令"><a href="#（2）乘法指令" class="headerlink" title="（2）乘法指令"></a>（2）乘法指令</h3><ul>
<li>ARM乘法指令完成2个寄存器中数据的乘法，按照保存结果的数据长度可以分为两类：一类为32位的乘法指令，即乘法操作的结果为32位；另一类为64位的乘法指令，即乘法操作的结果为64位。</li>
</ul>
<h4 id="1-32位乘法指令"><a href="#1-32位乘法指令" class="headerlink" title="1* 32位乘法指令"></a>1* 32位乘法指令</h4><img src="https://cdn.megalomania.icu/images/57f34def6e4eaaab731e00558eeadba2.png">

<h5 id="1-MUL"><a href="#1-MUL" class="headerlink" title="1. MUL"></a>1. MUL</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">MUL</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">     Rd, Rm, Rs</span></span><br></pre></td></tr></table></figure>
<ul>
<li>MUL指令实现两个32位的数（可以为无符号数，也可为有符号数）的乘积（Rm * Rs ）并将结果存放到一个32位的寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="2-MLA"><a href="#2-MLA" class="headerlink" title="2. MLA"></a>2. MLA</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">MLA</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">     Rd, Rm, Rs, Rn </span></span><br></pre></td></tr></table></figure>
<ul>
<li>MLA指令实现两个32位的数（可以为无符号数，也可为有符号数）的乘积，再将乘积（Rm * Rs ）加上第3个操作数Rn，并将结果存放到一个32位的寄存器Rd中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h4 id="2-64位乘法指令"><a href="#2-64位乘法指令" class="headerlink" title="2* 64位乘法指令"></a>2* 64位乘法指令</h4><img src="https://cdn.megalomania.icu/images/60472be9fbe72cca441f812c9586c080.png">

<h5 id="1-UMULL"><a href="#1-UMULL" class="headerlink" title="1. UMULL"></a>1. UMULL</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">UMULL</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  RdLo, RdHi, Rm, Rs </span></span><br></pre></td></tr></table></figure>
<ul>
<li>UMULL指令实现两个32位无符号数的乘积，乘积结果的高32位存放到一个32位的寄存器的RdHi，乘积结果的低32位存放到另一个32位的寄存器的RdLo；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="2-UMLAL"><a href="#2-UMLAL" class="headerlink" title="2. UMLAL"></a>2. UMLAL</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">UMLAL</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  RdLo, RdHi, Rm, Rs </span></span><br></pre></td></tr></table></figure>
<ul>
<li>UMLAL指令将两个32位无符号数的64位乘积结果与由（RdHi： RdLo）表示的64位无符号数相加，加法结果的高32位存放到寄存器RdHi中，加法结果的低32位存放到寄存器RdLo中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="3-SMULL"><a href="#3-SMULL" class="headerlink" title="3. SMULL"></a>3. SMULL</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">SMULL</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  RdLo, RdHi, Rm, Rs </span></span><br></pre></td></tr></table></figure>
<ul>
<li>SMULL指令实现两个32位有符号数的乘积，乘积结果的高32位存放到一个32位的寄存器的RdHi，乘积结果的低32位存放到另一个32位的寄存器的RdLo；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h5 id="4-SMLAL"><a href="#4-SMLAL" class="headerlink" title="4. SMLAL"></a>4. SMLAL</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">SMLAL</span><span class="template-variable">&#123;cond&#125;</span><span class="template-variable">&#123;S&#125;</span><span class="xml">  RdLo, RdHi, Rm, Rs </span></span><br></pre></td></tr></table></figure>
<ul>
<li>SMLAL指令将两个32位有符号数的64位乘积结果与由（RdHi： RdLo）表示的64位无符号数相加，加法结果的高32位存放到寄存器RdHi中，加法结果的低32位存放到寄存器RdLo中；如果指令包含后缀“S”，则根据操作结果更新CPSR中的相应条件标志位。</li>
</ul>
<h3 id="（3）杂类的数据处理指令"><a href="#（3）杂类的数据处理指令" class="headerlink" title="（3）杂类的数据处理指令"></a>（3）杂类的数据处理指令</h3><ul>
<li><p>从ARM V5版本指令系统开始支持杂类的数据处理指令CLZ（Count Leading Zeros，前导零计数指令），用于计算32位寄存器高位中“0”的个数。</p>
<img src="https://cdn.megalomania.icu/images/91ae53905ff16a6de07239cb38a13b1a.png">
</li>
<li><p>指令的汇编语法格式：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLZ <span class="tag">&lt;<span class="name">cond</span>&gt;</span> <span class="tag">&lt;<span class="name">Rd</span>&gt;</span>,<span class="tag">&lt;<span class="name">Rm</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>CLZ指令不影响条件码标志。</li>
<li>示例解析：</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span>    <span class="built_in">R4</span>，<span class="meta">#0xAA</span></span><br><span class="line"><span class="keyword">CLZ</span>   <span class="built_in">R2</span>，<span class="built_in">R4</span>		；执行后<span class="built_in">R2</span>中的值为<span class="number">24</span></span><br></pre></td></tr></table></figure>
<h2 id="2、ARM分支指令"><a href="#2、ARM分支指令" class="headerlink" title="2、ARM分支指令"></a>2、ARM分支指令</h2><ul>
<li><p>分支指令用于实现程序流程的跳转，在ARM程序中有两种方法可以实现程序流程的跳转：    </p>
<ol>
<li><p>使用专门的分支指令。</p>
</li>
<li><p>直接向程序计数器PC写入跳转地址值。</p>
</li>
</ol>
</li>
</ul>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><ul>
<li>ARM指令集中的跳转指令可以完成从当前指令向前或向后的32MB的地址空间的跳转，包括以下4条指令：    <ul>
<li>B 跳转指令</li>
<li>BL 带返回的跳转指令</li>
<li>BLX 带返回和状态切换的跳转指令</li>
<li>BX 带状态切换的跳转指令</li>
</ul>
</li>
</ul>
<blockquote>
<p>通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用MOV   LR，PC等类似指令，能够保存程序的返回地址值，从而实现在4GB连续地址空间的子程序调用。</p>
</blockquote>
<h4 id="1-分支指令B"><a href="#1-分支指令B" class="headerlink" title="1* 分支指令B"></a>1* 分支指令B</h4><ul>
<li>分支指令B可以实现跳转到指定的地址执行程序。</li>
<li>指令的汇编语法格式如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125;   <span class="tag">&lt;<span class="name">target_address</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/eecfd50b6295a43b843813ebfb1142d8.png">

<blockquote>
<p>在指令的汇编语法中target_address这个目标地址的计算方法是：将指令中的24位带符号的补码立即数扩展为32位；将此32位数左移两位将得到的值写入到程序计数器PC中，即跳转到目标地址。能够实现跳转的范围为-32MB~+32MB。</p>
</blockquote>
<ul>
<li>B指令是最简单的跳转指令。一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行。注意存储在跳转指令中的实际值是相对当前PC值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算。它是24位有符号数，左移两位后有符号扩展为 32 位，表示的有效偏移为 26 位(前后32MB的地址空间)。如：</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">B</span>	Label	  <span class="comment">/*程序无条件跳转到标号Label处执行*/</span></span><br></pre></td></tr></table></figure>
<h4 id="2-带链接的分支指令BL"><a href="#2-带链接的分支指令BL" class="headerlink" title="2* 带链接的分支指令BL"></a>2* 带链接的分支指令BL</h4><ul>
<li>带链接的分支指令BL可以实现跳转到指定的地址执行程序，同时BL指令还将程序计数器PC的值保存到LR寄存器中。</li>
<li>指令的汇编语法格式如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BL&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125;   <span class="tag">&lt;<span class="name">target_address</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/6a763e6485ac8a200fda501b195f6288.png">

<blockquote>
<p>L决定是否保存返回地址。当有L时，指令将下一条指令地址保存到LR寄存器中；当无L时同B指令仅执行跳转，当前PC寄存器的值将不会保存到LR寄存器中。从指令的编码可以看出，B与BL指令的唯一区别是bit[24]，当bit[24]=0是B指令，当bit[24]=1是BL指令。</p>
</blockquote>
<blockquote>
<p>BL跳转指令编码中signed_immed_24的含义同B指令。</p>
</blockquote>
<h4 id="3-带状态切换的跳转指令-BX"><a href="#3-带状态切换的跳转指令-BX" class="headerlink" title="3* 带状态切换的跳转指令 BX"></a>3* 带状态切换的跳转指令 BX</h4><ul>
<li>BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</li>
<li>指令的汇编语法格式如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BX&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125;   <span class="tag">&lt;<span class="name">Rm</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/7961aa7fa8390148da2845159ea16e37.png">

<blockquote>
<p>BX指令跳转到Rm指定的地址执行程序，如果Rm的bit[0]为1，则跳转时自动将CPSR中的标志位T置位，目标地址的代码为Thumb代码；如果Rm的bit[0]为0，则跳转时自动将CPSR中的T标志位清0，目标地址的代码为ARM代码。</p>
</blockquote>
<blockquote>
<p>如果 LSB=1, 则进入 Thumb 指令处理模式； 如果 LSB=0, 则进入 ARM 指令处理模式。</p>
</blockquote>
<h4 id="4-带链接和状态切换的跳转指令-BLX"><a href="#4-带链接和状态切换的跳转指令-BLX" class="headerlink" title="4* 带链接和状态切换的跳转指令 BLX"></a>4* 带链接和状态切换的跳转指令 BLX</h4><ul>
<li>BLX指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态由ARM状态切换到Thumb状态，该指令同时将程序计数器PC的当前内容保存到链接寄存器R14中。</li>
</ul>
<h5 id="1-由程序标号给出目标地址"><a href="#1-由程序标号给出目标地址" class="headerlink" title="1. 由程序标号给出目标地址"></a>1. 由程序标号给出目标地址</h5><ul>
<li>这种形式的BLX指令汇编语法格式如下：</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BLX</span>   &lt;target_address&gt;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/bdd43648e2bf084e98762ce56c8a1024.png">

<blockquote>
<p>目标地址target_address的计算方法：先对指令中定义的有符号24位偏移量用符号位扩展为32位，并将该32位数左移2位，然后将其加到程序计数器PC中，H位（bit[24]）加到目标地址的第1位（bit[1]），目标地址总是Thumb指令。跳转的范围为-32MB~+32MB。</p>
</blockquote>
<h5 id="2-寄存器的内容作为目标地址"><a href="#2-寄存器的内容作为目标地址" class="headerlink" title="2. 寄存器的内容作为目标地址"></a>2. 寄存器的内容作为目标地址</h5><ul>
<li>这种形式的BLX指令汇编语法格式如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLX&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125;   <span class="tag">&lt;<span class="name">Rm</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/cd8f1c506558c2cd8151b01c576ee5db.png">

<blockquote>
<p>BLX指令跳转到Rm指定的地址执行程序，如果Rm的bit[0]为1，则跳转时自动将CPSR中的标志位T置位，目标地址的代码为Thumb代码；如果Rm的bit[0]为0，则跳转时自动将CPSR中的T标志位清0，目标地址的代码为ARM代码。</p>
</blockquote>
<h2 id="3、加载-存储指令"><a href="#3、加载-存储指令" class="headerlink" title="3、加载/存储指令"></a>3、加载/存储指令</h2><ul>
<li>用于操作32位的字类型数据以及8位无符号的字节类型数据；</li>
<li>用于操作16位半字类型数据和8位的有符号字节类型数据。</li>
</ul>
<h3 id="（1）加载-存储字、无符号字节指令"><a href="#（1）加载-存储字、无符号字节指令" class="headerlink" title="（1）加载/存储字、无符号字节指令"></a>（1）加载/存储字、无符号字节指令</h3><h4 id="1-LDR-STR指令"><a href="#1-LDR-STR指令" class="headerlink" title="1* LDR/STR指令"></a>1* LDR/STR指令</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">LDR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">    Rd，<span class="tag">&lt;<span class="name">addressing</span>&gt;</span></span></span><br><span class="line"><span class="xml">STR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">    Rd，<span class="tag">&lt;<span class="name">addressing</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>LDR指令用于从内存中将一个32位的字数据读取到指令中的目标寄存器中。对于小端内存模式，指令读取的低地址字节数据存放在目标寄存器的低8位（bits[7：0]）；对于大端的内存模式，指令读取的低地址字节数据存放在目标寄存器的高8位（bits[31：24]）。</li>
<li>STR指令用于将一个32位寄存器中的字数据写入到指令中指定的内存单元。对于小端内存模式，寄存器的低8位存放在低地址字节单元；对于大端内存模式，寄存器的低8位存放在高地址字节单元。</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">LDR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">T    Rd，<span class="tag">&lt;<span class="name">addressing</span>&gt;</span></span></span><br><span class="line"><span class="xml">STR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">T    Rd，<span class="tag">&lt;<span class="name">addressing</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>LDRT/STRT是用户模式下的字数据加载/存储指令，当在特权极的处理器模式下使用本指令时，内存系统将该操作当作一般用户模式下的内存访问操作。这种指令在用户模式下使用无效，在特权模式下只能使用前变址形式。</p>
<img src="https://cdn.megalomania.icu/images/94d0967680d12be1b67cba0d140963ad.png">

<img src="https://cdn.megalomania.icu/images/7af1d646702ac2c315845401eddbab1b.png">

</li>
</ul>
<h4 id="2-LDRB-STRB指令"><a href="#2-LDRB-STRB指令" class="headerlink" title="2* LDRB/STRB指令"></a>2* LDRB/STRB指令</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">LDR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">B    Rd，<span class="tag">&lt;<span class="name">addressing</span>&gt;</span></span></span><br><span class="line"><span class="xml">STR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">B    Rd，<span class="tag">&lt;<span class="name">addressing</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>LDRB指令用于从内存中将一个8位的字节数据读取到指令中的目标寄存器低8位（bits[7:0]）中，寄存器的高24位（bits[31:8]）清零。</li>
<li>STRB指令用于将一个寄存器的低8位（bits[7:0]）写入到指令中指定的内存地址字节单元。</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">LDR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">BT  Rd，<span class="tag">&lt;<span class="name">addressing</span>&gt;</span></span></span><br><span class="line"><span class="xml">STR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">BT   Rd，<span class="tag">&lt;<span class="name">addressing</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>LDRBT/STRBT是用户模式下的字数据加载/存储指令，当在特权极的处理器模式下使用本指令时，内存系统将该操作当作一般用户模式下的内存访问操作。这种指令在用户模式下使用无效，在特权模式下只能使用前变址形式。</p>
<img src="https://cdn.megalomania.icu/images/e9f3479964a76a3a61e3a33758735fce.png">

<img src="https://cdn.megalomania.icu/images/7bb4a8c3da26fc64cd50dc03ff7decac.png">

</li>
</ul>
<h3 id="（2）半字、有符号字节访问指令"><a href="#（2）半字、有符号字节访问指令" class="headerlink" title="（2）半字、有符号字节访问指令"></a>（2）半字、有符号字节访问指令</h3><ul>
<li>半字数据访问指令用于内存中的数据与寄存器低16位数据进行操作，有符号字节访问指令可实现向寄存器加载8位的有符号字节数据。</li>
<li>对于向寄存器加载无符号半字数据，寄存器的高16位bits[31:16]清零；</li>
<li>对于向寄存器加载有符号半字数据，寄存器的高16位bits[31:16]用符号位扩展为32位；</li>
<li>对于向寄存器加载有符号字节数据，寄存器的高24位bits[31:8]用符号位扩展为32位。<img src="https://cdn.megalomania.icu/images/c8809486801c45f943988a4cf7960ad8.png">

</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">LDR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">H   Rd，<span class="tag">&lt;<span class="name">addressing</span> &gt;</span></span></span><br><span class="line"><span class="xml">STR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">H   Rd，<span class="tag">&lt;<span class="name">addressing</span> &gt;</span></span></span><br><span class="line"><span class="xml">LDR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">SH  Rd，<span class="tag">&lt;<span class="name">addressing</span> &gt;</span> </span></span><br><span class="line"><span class="xml">LDR</span><span class="template-variable">&#123;cond&#125;</span><span class="xml">SB  Rd, <span class="tag">&lt;<span class="name">addressing</span> &gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>S、H取值含义</p>
<img src="https://cdn.megalomania.icu/images/987442d923b2bcb685d157ae92543b1d.png">
</li>
<li><p>ARM微处理器所支持批量数据加载/存储指令可以一次性实现一片连续的存储器单元和多个寄存器之间进行传送数据。</p>
</li>
<li><p>批量数据加载指令用于将一片连续的存储器中的数据传送到多个寄存器中，批量数据存储指令能够实现将多个寄存器中的内容一次性的存放到一片连续的存储器中。</p>
</li>
</ul>
<h2 id="4、批量加载-存储指令"><a href="#4、批量加载-存储指令" class="headerlink" title="4、批量加载/存储指令"></a>4、批量加载/存储指令</h2><h3 id="（1）基本批量字数据加载-存储指令"><a href="#（1）基本批量字数据加载-存储指令" class="headerlink" title="（1）基本批量字数据加载/存储指令"></a>（1）基本批量字数据加载/存储指令</h3><ul>
<li>批量加载：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">LDM </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;<span class="params">&lt;addr_mode&gt;</span> <span class="params">&lt;Rn&gt;</span> &#123;!&#125;, <span class="params">&lt;registers&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>批量存储：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">STM </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;<span class="params">&lt;addr_mode&gt;</span> <span class="params">&lt;Rn&gt;</span> &#123;!&#125;, <span class="params">&lt;registers&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/559ebfe2bfad7720a61b5d7df72429d9.png"></p>
<p>​    <img src="https://cdn.megalomania.icu/images/7e7a52b0ed4eae5a5c959c578f016da2.png"></p>
<ul>
<li>注意事项：   <ul>
<li>Rn不允许为程序计数器PC（R15）</li>
<li>指令中寄存器和连续内存地址单元的对应关系：编号低的寄存器对应内存低地址单元，编号高的寄存器对应内存高地址单元。</li>
<li>如果指令中基址寄存器<code>&lt;Rn&gt;</code>在寄存器列表<code>&lt;registers&gt;</code>中，而且指令中寻址方式指定指令执行后更新基址寄存器<code>&lt;Rn&gt;</code> 的值，则指令执行会产生不可预知的结果。</li>
</ul>
</li>
</ul>
<h3 id="（2）用户模式下的批量字数据加载-存储指令"><a href="#（2）用户模式下的批量字数据加载-存储指令" class="headerlink" title="（2）用户模式下的批量字数据加载/存储指令"></a>（2）用户模式下的批量字数据加载/存储指令</h3><ul>
<li>用户模式下的批量字数据加载/存储指令操作实现的操作是：即使处理器工作在特权模式下，存储系统也将访问看成是处理器在用户模式下，因此所加载/存储的寄存器组为用户模式下的寄存器。该指令寄存器列表中不包含程序计数器PC，不允许对基地址寄存器回写操作。</li>
<li>用户模式下的批量字数据加载/存储指令汇编语法格式为</li>
<li>批量加载：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">LDM </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;<span class="params">&lt;addr_mode&gt;</span> <span class="params">&lt;Rn&gt;</span> , <span class="params">&lt;registers_without_pc&gt;</span>^</span><br></pre></td></tr></table></figure>
<ul>
<li>批量存储：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">STM </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;<span class="params">&lt;addr_mode&gt;</span> <span class="params">&lt;Rn&gt;</span> , <span class="params">&lt;registers_without_pc&gt;</span>^</span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/390c136c780ea0b4566b96743523edbb.png"></p>
<h3 id="（3）带PSR操作的批量字数据加载指令"><a href="#（3）带PSR操作的批量字数据加载指令" class="headerlink" title="（3）带PSR操作的批量字数据加载指令"></a>（3）带PSR操作的批量字数据加载指令</h3><ul>
<li>在带PSR操作的批量字数据加载指令中，程序计数器PC包含在指令寄存器列表中。</li>
<li>该指令将数据从连续的内存单元中读取到指令中寄存器列表中的各寄存器中。它同时将目前处理器模式对应的SPSR寄存器内容复制到CPSR寄存器中。</li>
<li>批量加载：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">LDM </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;<span class="params">&lt;addressing_mode&gt;</span> <span class="params">&lt;Rn&gt;</span> &#123;!&#125;, <span class="params">&lt;registers_with_pc&gt;</span>^</span><br></pre></td></tr></table></figure>
<ul>
<li>批量存储：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">STM </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;<span class="params">&lt;addressing_mode&gt;</span> <span class="params">&lt;Rn&gt;</span> &#123;!&#125;, <span class="params">&lt;registers_with_pc&gt;</span>^</span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/1e51f3f42d8d940fb8f55a849481f795.png"></p>
<h2 id="5、交换指令"><a href="#5、交换指令" class="headerlink" title="5、交换指令"></a>5、交换指令</h2><ul>
<li>ARM指令支持原子操作，主要是用来对信号量的操作，因为信号量操作的要求是作原子操作，即在一条指令中完成信号量的读取和修改操作。</li>
</ul>
<h3 id="（1）字数据交换指令"><a href="#（1）字数据交换指令" class="headerlink" title="（1）字数据交换指令"></a>（1）字数据交换指令</h3><ul>
<li>SWP是对字数据操作指令，用于将一个寄存器Rn为地址的内存字数据单元的内容读取到一个寄存器<code>&lt;Rd&gt;</code>中，同时将另一个寄存器Rm的内容写入到该内存单元中。</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWP&#123;&lt;cond&gt;&#125; &lt;Rd&gt;, &lt;Rm&gt;, <span class="meta">[&lt;Rn&gt;]</span></span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/b42aae6bbcefe8da7ac83384f1e85a37.png"></p>
<h3 id="（2）字节数据交换指令"><a href="#（2）字节数据交换指令" class="headerlink" title="（2）字节数据交换指令"></a>（2）字节数据交换指令</h3><ul>
<li>SWPB是对字节操作指令，用于将一个寄存器Rn为内存地址的字节数据单元的内容读取到一个寄存器Rd中，寄存器Rd的高24设置为0，同时将另一个寄存器Rm的低8位数值写入到该内存单元中</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWP&#123;&lt;cond&gt;&#125;&#123;B&#125;  &lt;Rd&gt;, &lt;Rm&gt;,<span class="meta">[&lt;Rn&gt;]</span></span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/68e603b03a4dec85dae66b34ecc563b1.png"></p>
<h2 id="6、程序状态寄存器PSR访问指令"><a href="#6、程序状态寄存器PSR访问指令" class="headerlink" title="6、程序状态寄存器PSR访问指令"></a>6、程序状态寄存器PSR访问指令</h2><h3 id="（1）读程序状态寄存器指令"><a href="#（1）读程序状态寄存器指令" class="headerlink" title="（1）读程序状态寄存器指令"></a>（1）读程序状态寄存器指令</h3><ul>
<li>MRS指令用于将状态寄存器的内容传送到通用寄存器中。这是程序获得程序状寄存器PSR数据的唯一方法。</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">MRS </span>&#123;<span class="params">&lt;cond&gt;</span>&#125; <span class="params">&lt;Rd&gt;</span>,  CPSR</span><br><span class="line"><span class="class">MRS </span>&#123;<span class="params">&lt;cond&gt;</span>&#125; <span class="params">&lt;Rd&gt;</span>,  SPSR</span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/2efada8e1b44c9192668f34e536e044d.png"></p>
<h3 id="（2）写程序状态寄存器指令"><a href="#（2）写程序状态寄存器指令" class="headerlink" title="（2）写程序状态寄存器指令"></a>（2）写程序状态寄存器指令</h3><ul>
<li>MSR指令用于将通用寄存器的内容或一个立即数传送到程序状态寄存器中，实现对程序状态寄存器的修改。</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">MSR </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;	 CPSR_<span class="params">&lt;fields&gt;</span>,  <span class="params">&lt; operand2&gt;</span>   </span><br><span class="line"><span class="class">MSR </span>&#123;<span class="params">&lt;cond&gt;</span>&#125;	 SPSR_<span class="params">&lt;fields&gt;</span>,  <span class="params">&lt; operand2&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/65ca09d4bb9e1d58afdf7790e5079098.png"></p>
<ul>
<li>fields设置状态寄存器中需要操作的位域。状态寄存器分为4个8位的域：        <ul>
<li>bits[31:24]为条件标志位域，用f表示；</li>
<li>bits[23:16]状态位域，用s表示；</li>
<li>bits[15:8]扩展位域，用x表示；</li>
</ul>
</li>
<li>bits[7:0]控制位域，用c表示；</li>
<li>第二操作数operand2的构成形式有以下两种形式：    <ul>
<li><code>&lt;immediate&gt;</code>为将要传送到状态寄存器中的立即数；</li>
</ul>
</li>
<li><code>&lt;Rm&gt;</code>寄存器包含将要传送到状态寄存器中的数据。</li>
<li>R（bit[22]）为0时，写CPSR；R（bit[22]）为1时，写SPSR。</li>
</ul>
<h2 id="7、协处理器操作指令"><a href="#7、协处理器操作指令" class="headerlink" title="7、协处理器操作指令"></a>7、协处理器操作指令</h2><ul>
<li>协处理器操作是ARM处理器对协处器进行管理，也就是ARM处理器的相关操作通过发送指令给协处理器，让协处理器来完成。ARM微处理器最多可支持16个协处理器，用于各种协处理操作。</li>
</ul>
<h3 id="（1）协处理器数据操作指令"><a href="#（1）协处理器数据操作指令" class="headerlink" title="（1）协处理器数据操作指令"></a>（1）协处理器数据操作指令</h3><ul>
<li>协处理器数据操作指令CDP用法：ARM处理器通知ARM协处理器执行特定的操作，若协处理器不能成功完成特定的操作，则产生未定义指令异常。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDP&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125; <span class="tag">&lt;<span class="name">Cp_num</span>&gt;</span>,<span class="tag">&lt;<span class="name">opcode_1</span>&gt;</span>,<span class="tag">&lt;<span class="name">CRd</span>&gt;</span>,<span class="tag">&lt;<span class="name">CRn</span>&gt;</span>,<span class="tag">&lt;<span class="name">CRm</span>&gt;</span>,&#123;<span class="tag">&lt;<span class="name">opcode_2</span>&gt;</span>&#125; </span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/5d4f1251fdc4903ec3afbe3cc7297337.png"></p>
<ul>
<li>cond为指令执行的条件码。当<code>&lt;cond&gt;</code>忽略时指令为无条件执行。</li>
<li>CRd为目标寄存器的协处理器寄存器。</li>
<li>CRn为存放第1个源操作数的协处理器寄存器。</li>
<li>CRm为存放第2个源操作数的协处理器寄存器。</li>
<li>Cp_num为协处理器的编码。</li>
<li>opcode1为协处理器将执行操作的第一操作码。</li>
<li>opcode2为协处理器将执行操作的第二操作码。（可选）</li>
</ul>
<h3 id="（2）协处理器加载-存储指令"><a href="#（2）协处理器加载-存储指令" class="headerlink" title="（2）协处理器加载/存储指令"></a>（2）协处理器加载/存储指令</h3><ul>
<li>协处理器的加载/存储指令可以用来实现ARM处理器与协处理器之间的数据传输，共有两条：协处理器数据加载指令LDC和协处理器数据存储指令STC。</li>
<li>协处理器的加载存储指令汇编语法格式如下：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">LDC</span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="template-variable">&#123;L&#125;</span><span class="xml"> <span class="tag">&lt;<span class="name">coproc</span>&gt;</span>，<span class="tag">&lt;<span class="name">CRd</span>&gt;</span>，<span class="tag">&lt;<span class="name">addressing_mode</span>&gt;</span></span></span><br><span class="line"><span class="xml">STC</span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="template-variable">&#123;L&#125;</span><span class="xml"> <span class="tag">&lt;<span class="name">coproc</span>&gt;</span>，<span class="tag">&lt;<span class="name">CRd</span>&gt;</span>，<span class="tag">&lt;<span class="name">addressing_mode</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/3a8f647629aa62b71a8fc2a38ae9a7a0.png"></p>
<ul>
<li>Rn为ARM处理器的通用寄存器，它用作基地址寄存器。</li>
<li>需要注意的是，汇编语法格式中的L是表示传输的数据为长整数，其对应指令编码中的“N”。而指令二进制编码中的“L”是用来区别LDC和STC指令。</li>
</ul>
<h4 id="1-协处理器数据加载指令LDC"><a href="#1-协处理器数据加载指令LDC" class="headerlink" title="1* 协处理器数据加载指令LDC"></a>1* 协处理器数据加载指令LDC</h4><ul>
<li>LDC指令用于将一系列连续的内存单元的数据读取到协处理器的寄存器中，并由协处理器来决定传输的字数。如果协处理器不能成功的执行该操作，将产生未定义的指令异常中断。<br>eg.</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">LDC</span>   P<span class="number">3</span>，CR<span class="number">4</span>，[R<span class="number">0</span>]	；将ARM处理器的寄存器R<span class="number">0</span>所指向的存储器中的字数据传送到协处理器P<span class="number">3</span>的CR<span class="number">4</span> 寄存器中</span><br></pre></td></tr></table></figure>
<h4 id="2-协处理器数据存储指令STC"><a href="#2-协处理器数据存储指令STC" class="headerlink" title="2* 协处理器数据存储指令STC"></a>2* 协处理器数据存储指令STC</h4><ul>
<li>STC指令将协处理器的寄存器中的数据写入到一系列连续的内存单元中，并由协处理器来决定传输的字数。如果协处理器不能成功的执行该操作，将产生未定义指令异常中断。</li>
</ul>
<h3 id="（3）ARM寄存器与协处理器寄存器数据传输指令"><a href="#（3）ARM寄存器与协处理器寄存器数据传输指令" class="headerlink" title="（3）ARM寄存器与协处理器寄存器数据传输指令"></a>（3）ARM寄存器与协处理器寄存器数据传输指令</h3><ul>
<li><p>ARM寄存器与协处理器寄存器数据传输指令用来实现ARM通用寄存器与协处理器寄存器之间的数据传输，共有两条：    1. ARM寄存器到协处理器寄存器的数据传送指令MCR</p>
<ol start="2">
<li>协处理器寄存器到ARM寄存器的数据传送指令MRC。</li>
</ol>
</li>
<li><p>ARM寄存器与协处理器寄存器数据传输指令汇编语法格式如下：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MCR&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125; <span class="tag">&lt;<span class="name">Cp_num</span>&gt;</span>,<span class="tag">&lt;<span class="name">opcode1</span>&gt;</span>,<span class="tag">&lt;<span class="name">Rd</span>&gt;</span>,<span class="tag">&lt;<span class="name">CRn</span>&gt;</span>,<span class="tag">&lt;<span class="name">CRm</span>&gt;</span>&#123;,<span class="tag">&lt;<span class="name">opcode2</span>&gt;</span>&#125;   </span><br><span class="line">MRC&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125; <span class="tag">&lt;<span class="name">Cp_num</span>&gt;</span>,<span class="tag">&lt;<span class="name">opcode1</span>&gt;</span>,<span class="tag">&lt;<span class="name">Rd</span>&gt;</span>,<span class="tag">&lt;<span class="name">CRn</span>&gt;</span>,<span class="tag">&lt;<span class="name">CRm</span>&gt;</span>&#123;,<span class="tag">&lt;<span class="name">opcode2</span>&gt;</span>&#125; </span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/e508ec5e3f2e17ed5b71d4cb881641fb.png"></p>
<p>​    <img src="https://cdn.megalomania.icu/images/37b2a4f06f3391dac9232e681cfa41f0.png"></p>
<h4 id="1-ARM寄存器到协处理器寄存器的数据传送指令MCR"><a href="#1-ARM寄存器到协处理器寄存器的数据传送指令MCR" class="headerlink" title="1* ARM寄存器到协处理器寄存器的数据传送指令MCR"></a>1* ARM寄存器到协处理器寄存器的数据传送指令MCR</h4><ul>
<li>MCR指令将ARM处理器的寄存器中的数据传送到协处理器的寄存器中。如果协处理器不能成功的执行该操作，将产生未定义的指令异常中断。<br>eg.</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MCR</span>  p<span class="number">6</span>，<span class="number">2</span>，R<span class="number">0</span>，CR<span class="number">1</span>，CR<span class="number">2</span>，<span class="number">4</span>     ；指令将ARM寄存器R<span class="number">0</span>中数据传送到协处理器p<span class="number">6</span>的寄存器中，其中R<span class="number">0</span>是存放源操作数的ARM寄存器，CR<span class="number">1</span>和CR<span class="number">2</span>是作为目标寄存器的协处理器寄存器，操作码<span class="number">1</span>为<span class="number">2</span>，操作码<span class="number">2</span>为<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="2-协处理器寄存器到ARM寄存器的数据传送指令MRC"><a href="#2-协处理器寄存器到ARM寄存器的数据传送指令MRC" class="headerlink" title="2* 协处理器寄存器到ARM寄存器的数据传送指令MRC"></a>2* 协处理器寄存器到ARM寄存器的数据传送指令MRC</h4><ul>
<li>MRC指令将协处理器的寄存器中的数据传送到ARM处理器的寄存器中。如果协处理器不能成功的执行该操作，将产生未定义的指令异常中断<br>eg.</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MRC</span>   p<span class="number">10</span>，<span class="number">3</span>，R<span class="number">3</span>，CR<span class="number">3</span>，CR<span class="number">4</span>，<span class="number">6</span>   ； 指令将协处理器p<span class="number">10</span>寄存器中的数据传送到ARM寄存器R<span class="number">3</span>中，其中R<span class="number">3</span>是存放目标操作数的ARM寄存器，CR<span class="number">3</span>和CR<span class="number">4</span>是作为目标寄存器的协处理器寄存器，操作码<span class="number">1</span>为<span class="number">3</span>，操作码<span class="number">2</span>为<span class="number">6</span> </span><br></pre></td></tr></table></figure>
<h2 id="8、异常产生指令"><a href="#8、异常产生指令" class="headerlink" title="8、异常产生指令"></a>8、异常产生指令</h2><ul>
<li><p>ARM处理器所支持的异常产生指令有两条：    </p>
<ol>
<li><p>软中断指令SWI</p>
</li>
<li><p>断点调试指令BKPT（用于ARM V5及以上的版本）</p>
</li>
</ol>
</li>
</ul>
<h3 id="（1）软中断指令"><a href="#（1）软中断指令" class="headerlink" title="（1）软中断指令"></a>（1）软中断指令</h3><ul>
<li>SWI(SoftWare Interrupt)指令用于产生软件中断，它将处理器置于监控模式(SVC)，从地址0x08开始执行指令。</li>
<li>ARM通过这种机制实现用户模式对操作系统中特权模式的程序调用，也就是使用户程序调用操作系统的系统程序成为可能。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125; <span class="tag">&lt;<span class="name">immed_24</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/0e04e6a0091e2ec1d6c44a927c75ee0a.png"></p>
<ul>
<li>操作系统在SWI的异常处理程序中提供相应的系统服务，指令中24位的立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递。</li>
<li>执行过程：   <ul>
<li>将SWI后面指令地址保存到R14_svc;</li>
<li>将CPSR保存到SPSR_svc;</li>
<li>进入监控模式,将CPSR[4:0]设置为0b10011的将CPSR[7]设置为[1],禁止IRQ；</li>
<li>将PC设置为0x08,并且开始执行那里的指令。</li>
<li>返回时：MOVS PC，R14</li>
</ul>
</li>
</ul>
<h3 id="（2）断点中断指令"><a href="#（2）断点中断指令" class="headerlink" title="（2）断点中断指令"></a>（2）断点中断指令</h3><ul>
<li>BKPT (BreakPoinT)指令产生软件断点中断，可用于程序的调试。当BKPT指令执行时，处理器停止执行下面的指令并进入相应的BKPT入口程序</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">BKPT</span>	 &lt;immed_<span class="number">16</span>&gt; </span><br></pre></td></tr></table></figure>
<p>​    <img src="https://cdn.megalomania.icu/images/6293f134534a8c9804828dc247d05074.png"></p>
<ul>
<li>immed_16为16位的立即数，此立即数被调试软件用来保存额外的断点信息。</li>
</ul>
<h1 id="五、ARM汇编伪指令与伪操作"><a href="#五、ARM汇编伪指令与伪操作" class="headerlink" title="五、ARM汇编伪指令与伪操作"></a>五、ARM汇编伪指令与伪操作</h1><h2 id="1、汇编语言伪指令"><a href="#1、汇编语言伪指令" class="headerlink" title="1、汇编语言伪指令"></a>1、汇编语言伪指令</h2><ul>
<li>伪指令是ARM处理器支持的汇编语言程序里的特殊助记符，它不在处理器运行期间由机器执行,只是在汇编时将被合适的机器指令代替成ARM或Thumb指令,从而实现真正的指令操作。</li>
</ul>
<h3 id="（1）伪指令的意义"><a href="#（1）伪指令的意义" class="headerlink" title="（1）伪指令的意义"></a>（1）伪指令的意义</h3><ul>
<li>伪指令不是指令，伪指令和指令的根本区别是经过编译后会不会生成机器码。</li>
<li>伪指令的意义在于指导编译过程。</li>
<li>伪指令是和具体的编译器相关的</li>
</ul>
<h3 id="（2）汇编中的一些符号"><a href="#（2）汇编中的一些符号" class="headerlink" title="（2）汇编中的一些符号"></a>（2）汇编中的一些符号</h3><ul>
<li>@用来做注释。可以在行首也可以在代码后面同一行直接跟，和C语言中//类似</li>
<li>#做注释，一般放在行首，表示这一行都是注释而不是代码。</li>
<li>：以冒号结尾的是标号</li>
<li>. 点号在gnu汇编中表示当前指令的地址</li>
<li>#立即数前面要加#或$，表示这是个立即数</li>
</ul>
<h3 id="（3）常用伪指令"><a href="#（3）常用伪指令" class="headerlink" title="（3）常用伪指令"></a>（3）常用伪指令</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.global</span> _start		@ 给_start外部链接属性</span><br><span class="line"><span class="string">.section</span> <span class="string">.text</span>		@ 指定当前段为代码段</span><br><span class="line"><span class="string">.ascii</span> <span class="string">.byte</span> <span class="string">.short</span> <span class="string">.long</span> <span class="string">.word</span> </span><br><span class="line"><span class="string">.quad</span> <span class="string">.float</span> <span class="string">.string</span> @ 定义数据</span><br><span class="line"><span class="string">.align</span> 4			@ 以16字节对齐</span><br><span class="line"><span class="string">.balignl</span> 16 0xabcdefgh 	@ 16字节对齐填充</span><br><span class="line"><span class="string">.equ</span>			@ 类似于C中宏定义</span><br><span class="line"><span class="string">.end</span>			@标识文件结束</span><br><span class="line"><span class="string">.include</span>			@ 头文件包含</span><br><span class="line"><span class="string">.arm</span> / <span class="string">.code32</span>	@声明以下为arm指令</span><br><span class="line"><span class="string">.thumb</span> / <span class="string">.code16</span>	@声明以下为thubm指令</span><br></pre></td></tr></table></figure>
<h3 id="（4）ARM汇编语言伪指令"><a href="#（4）ARM汇编语言伪指令" class="headerlink" title="（4）ARM汇编语言伪指令"></a>（4）ARM汇编语言伪指令</h3><h4 id="1-大范围地址读取伪指令LDR"><a href="#1-大范围地址读取伪指令LDR" class="headerlink" title="1* 大范围地址读取伪指令LDR"></a>1* 大范围地址读取伪指令LDR</h4><ul>
<li>LDR伪指令将一个32位的常数或者一个地址值读取到寄存器中，可以看作是加载寄存器的内容。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;cond&#125; 	<span class="keyword">register</span> , = expression </span><br></pre></td></tr></table></figure>
<ul>
<li>如果加载的常数符合MOV或MVN指令立即数的要求，则用MOV或MVN指令替代LDR伪指令。</li>
<li>如果加载的常数不符合MOV或MVN指令立即数的要求，汇编器将常量放入内存文字池，并使用一条程序相对偏移的LDR指令从内存文字池读出常量。</li>
</ul>
<blockquote>
<p>文字池：文字池的本质就是ARM汇编语言代码节中的一块用来存放常量数据而非可执行代码的内存块。</p>
</blockquote>
<h4 id="2-中等范围地址读取伪指令ADRL"><a href="#2-中等范围地址读取伪指令ADRL" class="headerlink" title="2* 中等范围地址读取伪指令ADRL"></a>2* 中等范围地址读取伪指令ADRL</h4><ul>
<li>它将基于PC相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADRL&#123;cond&#125; 	<span class="keyword">register</span> , = expression</span><br></pre></td></tr></table></figure>
<ul>
<li>汇编器在处理源程序时，ADRL伪指令被两条具有ADRL等同功能的ARM指令(通常用ADD或SUB指令)替代。</li>
<li>如果不能用两条指令实现ADRL伪指令的功能，则编译器报告错误，编译失败。</li>
</ul>
<h4 id="3-小范围地址读取伪指令ADR"><a href="#3-小范围地址读取伪指令ADR" class="headerlink" title="3* 小范围地址读取伪指令ADR"></a>3* 小范围地址读取伪指令ADR</h4><ul>
<li>它将基于PC相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中。当地址是字节对齐时，取值范围为-255~+255</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADR&#123;cond&#125; 	<span class="keyword">register</span> , = expression</span><br></pre></td></tr></table></figure>
<h4 id="4-空操作伪指令NOP"><a href="#4-空操作伪指令NOP" class="headerlink" title="4* 空操作伪指令NOP"></a>4* 空操作伪指令NOP</h4><ul>
<li>NOP是空操作伪指令，在汇编时将会被替代成ARM中的空操作 .</li>
</ul>
<h3 id="（5）Thumb汇编语言伪指令"><a href="#（5）Thumb汇编语言伪指令" class="headerlink" title="（5）Thumb汇编语言伪指令"></a>（5）Thumb汇编语言伪指令</h3><h4 id="1-大范围地址读取伪指令LDR-1"><a href="#1-大范围地址读取伪指令LDR-1" class="headerlink" title="1* 大范围地址读取伪指令LDR"></a>1* 大范围地址读取伪指令LDR</h4><ul>
<li>LDR伪指令将一个32位的常数或者一个地址值读取到寄存器中，可以看作是加载寄存器的内容。其语法格式如下：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR 	<span class="keyword">register</span> , = expression</span><br></pre></td></tr></table></figure>
<h4 id="2-小范围地址读取伪指令ADR"><a href="#2-小范围地址读取伪指令ADR" class="headerlink" title="2* 小范围地址读取伪指令ADR"></a>2* 小范围地址读取伪指令ADR</h4><ul>
<li>ADR为小范围地址读取伪指令，它将基于PC相对偏移的地址值读取到寄存器中。偏移量必须是正数并小于1KB。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADR 	<span class="keyword">register</span> , = expression</span><br></pre></td></tr></table></figure>
<ul>
<li>相当于PC寄存器或其它寄存器的长转移。</li>
<li>汇编器在处理源程序时，ADR伪指令一条具有ADR等同功能的thumb指令(通常用ADD或SUB指令)替代。</li>
<li>如果不能用一条指令实现ADR伪指令的功能，则编译器报告错误，编译失败。</li>
</ul>
<h4 id="3-空操作伪指令NOP"><a href="#3-空操作伪指令NOP" class="headerlink" title="3* 空操作伪指令NOP"></a>3* 空操作伪指令NOP</h4><ul>
<li>NOP是空操作伪指令，在汇编时将会被替代成ARM中的空操作（也就是什么也没做）指令，例如可能为：“MOV R0，R0”</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NOP</span></span><br></pre></td></tr></table></figure>
<ul>
<li>空操作伪指令可用于延时操作。</li>
</ul>
<h2 id="2、汇编语言伪操作"><a href="#2、汇编语言伪操作" class="headerlink" title="2、汇编语言伪操作"></a>2、汇编语言伪操作</h2><ul>
<li><p>伪操作(Directive)是ARM汇编语言程序里的一些特殊的指令助记符,其作用主要是为完成汇编程序做各种准备工作,对源程序运行汇编程序处理,而不是在计算机运行期间由处理器执行。</p>
</li>
<li><p>伪操作只是汇编过程中起作用,一旦汇编结束,伪操作也就随之消失。</p>
</li>
<li><p>目前常用的编译环境有2种：    </p>
<ol>
<li><p>ADS/SDT、RealView MDK等ARM公司推出的开发工具</p>
</li>
<li><p>GNU ARM开发工具</p>
</li>
</ol>
</li>
</ul>
<h2 id="3、GNU-ARM汇编伪操作"><a href="#3、GNU-ARM汇编伪操作" class="headerlink" title="3、GNU ARM汇编伪操作"></a>3、GNU ARM汇编伪操作</h2><ul>
<li>在嵌入式系统开发中，不可避免的要使用GNU工具，要进行嵌入式LINUX的移植与开发，其中与硬件直接相关的部分要用汇编语言来编程。</li>
</ul>
<h3 id="（1）符号定义伪操作"><a href="#（1）符号定义伪操作" class="headerlink" title="（1）符号定义伪操作"></a>（1）符号定义伪操作</h3><h4 id="1-常量定义伪操作-equ或-set"><a href="#1-常量定义伪操作-equ或-set" class="headerlink" title="1* 常量定义伪操作.equ或.set"></a>1* 常量定义伪操作.equ或.set</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.equ    symbol, <span class="built_in">expr</span></span><br><span class="line">.<span class="built_in">set</span>    symbol, <span class="built_in">expr</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>symbol 为要指定的名称，它可以是以前定义过的符号；</li>
<li>expr 表示数字常量或程序中的标号。</li>
</ul>
</li>
</ul>
<h4 id="2-常量定义伪操作-equiv"><a href="#2-常量定义伪操作-equiv" class="headerlink" title="2* 常量定义伪操作.equiv"></a>2* 常量定义伪操作.equiv</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.equiv 	symbol, expr</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>symbol 为要指定的名称，它<strong>不可以是以前定义过的符号</strong>；</li>
<li>expr 表示数字常量或程序中的标号。</li>
</ul>
</li>
</ul>
<h4 id="3-声明全局常量伪操作-global或-globl"><a href="#3-声明全局常量伪操作-global或-globl" class="headerlink" title="3* 声明全局常量伪操作.global或.globl"></a>3* 声明全局常量伪操作.global或.globl</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.global 	symbol</span></span><br><span class="line"><span class="title">.globl 	symbol</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>symbol 为要声明的全局变量名称</li>
</ul>
</li>
</ul>
<h4 id="4-声明外部常量伪操作-extern"><a href="#4-声明外部常量伪操作-extern" class="headerlink" title="4* 声明外部常量伪操作.extern"></a>4* 声明外部常量伪操作.extern</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="keyword">extern</span> 	symbol</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>symbol 为要声明的外部变量名称</li>
</ul>
</li>
</ul>
<h3 id="（2）数据定义伪操作"><a href="#（2）数据定义伪操作" class="headerlink" title="（2）数据定义伪操作"></a>（2）数据定义伪操作</h3><h4 id="1-字节定义-byte"><a href="#1-字节定义-byte" class="headerlink" title="1* 字节定义.byte"></a>1* 字节定义.byte</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.byte	 <span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;…</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 数字表达式或程序中的标号。</li>
</ul>
</li>
</ul>
<h4 id="2-半字定义-hword或-short"><a href="#2-半字定义-hword或-short" class="headerlink" title="2* 半字定义.hword或.short"></a>2* 半字定义.hword或.short</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.hword 	<span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;….</span><br><span class="line">.short 	<span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;…</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 数字表达式或程序中的标号。</li>
</ul>
</li>
</ul>
<h4 id="3-字定义-word或-int或-long"><a href="#3-字定义-word或-int或-long" class="headerlink" title="3* 字定义.word或.int或.long"></a>3* 字定义.word或.int或.long</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.word 	<span class="built_in">expr</span> &#123;, <span class="built_in">expr</span> &#125;….</span><br><span class="line">.<span class="built_in">int</span>		<span class="built_in">expr</span> &#123;, <span class="built_in">expr</span> &#125;…</span><br><span class="line">.long 	<span class="built_in">expr</span> &#123;, <span class="built_in">expr</span> &#125;…</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 数字表达式或程序中的标号。</li>
</ul>
</li>
</ul>
<h4 id="4-字符串定义-ascii和-asciz或-string"><a href="#4-字符串定义-ascii和-asciz或-string" class="headerlink" title="4* 字符串定义.ascii和.asciz或.string"></a>4* 字符串定义.ascii和.asciz或.string</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.ascii	<span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;…</span><br><span class="line">.asciz 	<span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;…</span><br><span class="line">.<span class="keyword">string</span> 	<span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;…</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 表示字符串。</li>
</ul>
</li>
</ul>
<h4 id="5-双字定义-quad"><a href="#5-双字定义-quad" class="headerlink" title="5* 双字定义.quad"></a>5* 双字定义.quad</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.quad 	<span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;…</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 数字表达式。</li>
</ul>
</li>
</ul>
<h4 id="6-四字定义-octa"><a href="#6-四字定义-octa" class="headerlink" title="6* 四字定义.octa"></a>6* 四字定义.octa</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.octa	 <span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;…</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 数字表达式。</li>
</ul>
</li>
</ul>
<h4 id="7-单精度浮点数定义-float或-single"><a href="#7-单精度浮点数定义-float或-single" class="headerlink" title="7* 单精度浮点数定义.float或.single"></a>7* 单精度浮点数定义.float或.single</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">float</span> 	<span class="built_in">expr</span> &#123;, <span class="built_in">expr</span> &#125;….</span><br><span class="line">.single 	<span class="built_in">expr</span> &#123;, <span class="built_in">expr</span> &#125;….</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 为32位的 IEEE 单精度浮点数。</li>
</ul>
</li>
</ul>
<h4 id="8-双精度浮点数定义-double"><a href="#8-双精度浮点数定义-double" class="headerlink" title="8* 双精度浮点数定义.double"></a>8* 双精度浮点数定义.double</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.double	 <span class="keyword">expr</span> &#123;, <span class="keyword">expr</span> &#125;…</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 为32位的 IEEE 双精度浮点数</li>
</ul>
</li>
</ul>
<h4 id="9-重复内存单元定义-fill"><a href="#9-重复内存单元定义-fill" class="headerlink" title="9* 重复内存单元定义.fill"></a>9* 重复内存单元定义.fill</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">fill</span>	 repeat &#123;, <span class="built_in">size</span>&#125;&#123;, value&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>repeat 重复填充的次数；</li>
<li>size 每次所填充的字节数；</li>
<li>value 所填充的数据。</li>
</ul>
</li>
</ul>
<h4 id="10-零填充字节内存单元定义-zero"><a href="#10-零填充字节内存单元定义-zero" class="headerlink" title="10* 零填充字节内存单元定义.zero"></a>10* 零填充字节内存单元定义.zero</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.zero <span class="built_in">size</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>size 所分配的0填充字节数</li>
</ul>
</li>
</ul>
<h4 id="11-固定填充字节内存单元定义-space或-skip"><a href="#11-固定填充字节内存单元定义-space或-skip" class="headerlink" title="11* 固定填充字节内存单元定义.space或.skip"></a>11* 固定填充字节内存单元定义.space或.skip</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.space 	<span class="built_in">size</span> &#123;, value&#125;</span><br><span class="line">.skip 	<span class="built_in">size</span> &#123;, value&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>size 所分配的字节数</li>
</ul>
</li>
</ul>
<h4 id="12-声明数据缓冲池-ltorg"><a href="#12-声明数据缓冲池-ltorg" class="headerlink" title="12* 声明数据缓冲池.ltorg"></a>12* 声明数据缓冲池.ltorg</h4><ul>
<li>语法格式</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.ltorg</span></span><br></pre></td></tr></table></figure>
<h3 id="（3）汇编与反汇编代码控制伪操作"><a href="#（3）汇编与反汇编代码控制伪操作" class="headerlink" title="（3）汇编与反汇编代码控制伪操作"></a>（3）汇编与反汇编代码控制伪操作</h3><h4 id="1-指令集类型标识伪操作"><a href="#1-指令集类型标识伪操作" class="headerlink" title="1* 指令集类型标识伪操作"></a>1* 指令集类型标识伪操作</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.arm</span></span><br><span class="line"><span class="title">.code 32</span></span><br><span class="line"><span class="title">.thumb</span></span><br><span class="line"><span class="title">.code 16</span></span><br></pre></td></tr></table></figure>
<h4 id="2-段属性定义伪操作"><a href="#2-段属性定义伪操作" class="headerlink" title="2* 段属性定义伪操作"></a>2* 段属性定义伪操作</h4><ul>
<li>语法格式如下：</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.section expr</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>expr 为段属性，可以是.text、.data、.bss中的一个。</li>
</ul>
</li>
</ul>
<h4 id="3-段起始声明伪操作"><a href="#3-段起始声明伪操作" class="headerlink" title="3* 段起始声明伪操作"></a>3* 段起始声明伪操作</h4><ul>
<li>具体的语法格式如下：</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.text</span></span><br><span class="line"><span class="title">.data</span></span><br><span class="line"><span class="title">.bss</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/2b2b16e20e2c1e2383e2bc0e1bfacec5.png">

<h4 id="4-对齐方式设置伪操作-align或-balign"><a href="#4-对齐方式设置伪操作-align或-balign" class="headerlink" title="4* 对齐方式设置伪操作.align或.balign"></a>4* 对齐方式设置伪操作.align或.balign</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">.align	 </span><span class="template-variable">&#123;alignment&#125;</span><span class="xml"> </span><span class="template-variable">&#123;, fill&#125;</span><span class="xml"> </span></span><br><span class="line"><span class="xml">.balign	 </span><span class="template-variable">&#123;alignment&#125;</span><span class="xml"> </span><span class="template-variable">&#123;, fill&#125;</span><span class="xml"> </span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>alignment 是一个数值表达式，用于指定对齐方式，其取值在0~15范围内；</li>
<li>fill 用来指定进行填充的数据。</li>
</ul>
</li>
</ul>
<h4 id="5-代码位置设置伪操作-org"><a href="#5-代码位置设置伪操作-org" class="headerlink" title="5* 代码位置设置伪操作.org"></a>5* 代码位置设置伪操作.org</h4><ul>
<li>语法格式:</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.org	 <span class="built_in">offset</span> &#123;, expr&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>offset 是一个数值表达式，表示地址偏移量；</li>
<li>expr 用来指定进行填充的数据。</li>
</ul>
</li>
</ul>
<h3 id="（4）预定义控制伪操作"><a href="#（4）预定义控制伪操作" class="headerlink" title="（4）预定义控制伪操作"></a>（4）预定义控制伪操作</h3><ul>
<li>汇编器在对程序代码进行编译时，会根据汇编控制伪操作的定义情况对程序进行编译，常用的有条件编译、宏定义和文件包含</li>
</ul>
<h4 id="1-条件编译伪操作-if"><a href="#1-条件编译伪操作-if" class="headerlink" title="1* 条件编译伪操作.if"></a>1* 条件编译伪操作.if</h4><ul>
<li>语法格式：</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.if</span>	logical_expression</span><br><span class="line">程序代码段A	</span><br><span class="line">&#123;<span class="meta">.else</span></span><br><span class="line">程序代码段<span class="keyword">B</span></span><br><span class="line"><span class="keyword">&#125;	</span>.</span><br><span class="line"><span class="meta">.endif</span> </span><br></pre></td></tr></table></figure>
<h4 id="2-宏定义伪操作-macro"><a href="#2-宏定义伪操作-macro" class="headerlink" title="2* 宏定义伪操作.macro"></a>2* 宏定义伪操作.macro</h4><ul>
<li>语法格式：</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.macro</span></span><br><span class="line">&#123;	macroname	&#123;parameter&#123;,parameter&#125;…&#125;</span><br><span class="line">程序代码段</span><br><span class="line"><span class="title">.endm其中：	</span></span><br></pre></td></tr></table></figure>
<h4 id="3-文件包含伪操作-include"><a href="#3-文件包含伪操作-include" class="headerlink" title="3* 文件包含伪操作.include"></a>3* 文件包含伪操作.include</h4><ul>
<li>.include伪操作用于将一个源文件包含到当前的源文件中，所包含的文件在.include指令的位置处进行汇编处理。</li>
<li>语法格式:</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.include</span> 	<span class="string">&quot;file_name&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="六、汇编语言程序设计"><a href="#六、汇编语言程序设计" class="headerlink" title="六、汇编语言程序设计"></a>六、汇编语言程序设计</h1><h2 id="1、ARM编译环境下汇编语句"><a href="#1、ARM编译环境下汇编语句" class="headerlink" title="1、ARM编译环境下汇编语句"></a>1、ARM编译环境下汇编语句</h2><ul>
<li>ARM编译环境下进行汇编语言程序设计的格式</li>
<li>汇编语句中的符号规则</li>
</ul>
<h3 id="（1）ADS环境下ARM汇编语句格式"><a href="#（1）ADS环境下ARM汇编语句格式" class="headerlink" title="（1）ADS环境下ARM汇编语句格式"></a>（1）ADS环境下ARM汇编语句格式</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;symbol&#125; &#123;instruction&#125;	&#123;<span class="comment">;comment&#125;</span></span><br><span class="line">&#123;symbol&#125; &#123;directive&#125;	&#123;<span class="comment">;comment&#125;</span></span><br><span class="line">&#123;symbol&#125;&#123; pseudo-instruction&#125;	&#123;<span class="comment">;comment&#125;</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/f7fd7aca3071e3108c2c5b9957c1cf8e.png">

<h3 id="（2）ADS编译环境下汇编语句中符号规则"><a href="#（2）ADS编译环境下汇编语句中符号规则" class="headerlink" title="（2）ADS编译环境下汇编语句中符号规则"></a>（2）ADS编译环境下汇编语句中符号规则</h3><h4 id="1-符号命名规则"><a href="#1-符号命名规则" class="headerlink" title="1* 符号命名规则"></a>1* 符号命名规则</h4><ol>
<li>符号由大小写字母、数字、下划线组成，且符号是区分大小写的；</li>
<li>局部标号可以用数字开头，其他的标号不能；</li>
<li>符号在其作用范围内必须是唯一的；</li>
<li>程序中的符号不要与指令助记符或者伪操作同名。</li>
</ol>
<h4 id="2-常量"><a href="#2-常量" class="headerlink" title="2* 常量"></a>2* 常量</h4><ol>
<li>十进制数，如535、246。</li>
<li>十六进制数，如0x645、0xff00。</li>
<li>n_XXX, n表示n进制数，从2~9，XXX是具体的数字。例如：8_3777</li>
<li>字符常量用一对单引号括起来，包括一个单字符或者标准C中的转义字符。例如‘A’、‘\n’。</li>
<li>字符串常量由一对双引号以及由它括住的一组字符串组成，包括标准C中的转义字符。<ul>
<li>如果需要使用双引号”或字符$ ，则必须用””和$$代替</li>
</ul>
</li>
</ol>
<h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3* 变量"></a>3* 变量</h4><ol>
<li>数字变量—汇编器对-n和232-n不做区别</li>
<li>字符串变量—字符串变量最大长度为512字节</li>
<li>逻辑变量—{FALSE}和{TRUE}</li>
</ol>
<h4 id="4-字符串表达式操作"><a href="#4-字符串表达式操作" class="headerlink" title="4* 字符串表达式操作"></a>4* 字符串表达式操作</h4><h5 id="1-取符串的长度LEN"><a href="#1-取符串的长度LEN" class="headerlink" title="1. 取符串的长度LEN"></a>1. 取符串的长度LEN</h5><ul>
<li>语法格式：</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">:LEN:</span> A</span><br></pre></td></tr></table></figure>
<ul>
<li>功能说明：返回字符串A的长度。</li>
</ul>
<h5 id="2-CHR"><a href="#2-CHR" class="headerlink" title="2. CHR"></a>2. CHR</h5><ul>
<li>语法格式：</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">:CHR:</span> A </span><br></pre></td></tr></table></figure>
<ul>
<li>功能说明：将A（A为某一字符的ASCII值）转换为单个字符。</li>
</ul>
<h5 id="3-STR"><a href="#3-STR" class="headerlink" title="3. STR"></a>3. STR</h5><ul>
<li>语法格式：</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">:STR:</span> A </span><br></pre></td></tr></table></figure>
<ul>
<li>功能说明：将A（A为数字量或逻辑表达式）转换成字符串。</li>
</ul>
<h5 id="4-LEFT"><a href="#4-LEFT" class="headerlink" title="4. LEFT"></a>4. LEFT</h5><ul>
<li>语法格式：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A :</span><span class="attr">LEFT:</span> B </span><br></pre></td></tr></table></figure>
<ul>
<li>功能说明：返回字符串A最左端B（B为返回长度）长度的字符串。</li>
</ul>
<h5 id="5-RIGHT"><a href="#5-RIGHT" class="headerlink" title="5. RIGHT"></a>5. RIGHT</h5><ul>
<li>返回一个字符串最右端一定长度的字符串：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A :</span><span class="attr">RIGHT:</span> B</span><br></pre></td></tr></table></figure>
<ul>
<li>功能说明：返回字符串A最右端B（B为返回长度）长度的字符串。</li>
</ul>
<h5 id="6-CC"><a href="#6-CC" class="headerlink" title="6. CC"></a>6. CC</h5><ul>
<li>用于连接两个字符串，B串接到A串后面：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A :</span><span class="attr">CC:</span> B </span><br></pre></td></tr></table></figure>
<h4 id="5-地址标号"><a href="#5-地址标号" class="headerlink" title="5* 地址标号"></a>5* 地址标号</h4><ol>
<li>PC相关标号</li>
<li>寄存器相关标号</li>
<li>绝对地址</li>
</ol>
<h4 id="6-局部标号"><a href="#6-局部标号" class="headerlink" title="6* 局部标号"></a>6* 局部标号</h4><ul>
<li>局部标号的语法格式如下：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">n </span>&#123;routname&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>被引用的局部标号语法规则是：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">% </span><span class="template-variable">&#123;F∣B&#125;</span><span class="xml"> </span><span class="template-variable">&#123;A∣T&#125;</span><span class="xml"> n </span><span class="template-variable">&#123;routname&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：    <ul>
<li>n是局部标号的数字号。</li>
<li>routname是当前局部范围的名称。</li>
<li>%表示引用操作。</li>
<li>F指示汇编器只向前搜索。</li>
<li>B指示汇编器只向后搜索。</li>
<li>A指示汇编器搜索宏的所有嵌套层次。</li>
<li>T指示汇编器搜索宏的当前层次。</li>
</ul>
</li>
</ul>
<h2 id="2、GNU环境下汇编语句与编译说明"><a href="#2、GNU环境下汇编语句与编译说明" class="headerlink" title="2、GNU环境下汇编语句与编译说明"></a>2、GNU环境下汇编语句与编译说明</h2><ul>
<li>GNU环境下ARM汇编语言程序设计主要是面对在ARM平台上进行嵌入式LINUX的开发。</li>
<li>GNU标准中提供了支持ARM汇编语言的汇编器as(arm-elf-as)、交叉编译器gcc ld(arm-elf-gcc)和链接器ld(arm-elf-ld)。</li>
</ul>
<h3 id="（1）GNU环境下ARM汇编语句格式"><a href="#（1）GNU环境下ARM汇编语句格式" class="headerlink" title="（1）GNU环境下ARM汇编语句格式"></a>（1）GNU环境下ARM汇编语句格式</h3><ul>
<li>GNU环境下ARM汇编语言语句格式如下：</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;label :&#125; 	&#123;instruction&#125;			&#123;@comment&#125;</span><br><span class="line">&#123;label :&#125;	&#123;directive&#125;			&#123;@comment&#125;</span><br><span class="line">&#123;label :&#125;  	&#123; pseudo-instruction&#125;	&#123;@comment&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）GNU环境下ARM汇编程序编译"><a href="#（2）GNU环境下ARM汇编程序编译" class="headerlink" title="（2）GNU环境下ARM汇编程序编译"></a>（2）GNU环境下ARM汇编程序编译</h3><h4 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1* 预处理"></a>1* 预处理</h4><ul>
<li>GNU汇编器as的内部预处理包括：移除多余的间隔符代码中的所有注释，并将字符常量转换为数字值。它不作宏处理和文件包含处理，但这些事情可以交由gcc编译器去做，文件包含可以用.include伪指令来实现。</li>
</ul>
<h4 id="2-注释"><a href="#2-注释" class="headerlink" title="2* 注释"></a>2* 注释</h4><ul>
<li>GNU ARM Assembly可识别的注释方式有：</li>
<li>C风格多行注释符/* … */</li>
<li>GNU单行注释符“@”或“#”。</li>
</ul>
<h4 id="3-符号"><a href="#3-符号" class="headerlink" title="3* 符号"></a>3* 符号</h4><ul>
<li>与C语言基本一致，符号名由字母、数字以及’_’、和’.’组成，大小写敏感。</li>
</ul>
<h4 id="4-段与重定位"><a href="#4-段与重定位" class="headerlink" title="4* 段与重定位"></a>4* 段与重定位</h4><ul>
<li>链接器ld用于把多个目标文件合并为一个可执行文件。</li>
<li>汇编器as生成的目标文件都假定从地址0开始，ld为其指定最终的地址。</li>
<li>链接器ld把目标文件中的每个section都作为一个整体，为其分配运行的地址<img src="https://cdn.megalomania.icu/images/7c10724721cb29d6e15dc5d004e79dc3.png">

</li>
</ul>
<h4 id="5-符号说明"><a href="#5-符号说明" class="headerlink" title="5* 符号说明"></a>5* 符号说明</h4><h5 id="1-label"><a href="#1-label" class="headerlink" title="1. label"></a>1. label</h5><ul>
<li>lable后面要带冒号‘：’，例如：</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">_start:</span> <span class="keyword">B</span> Reset_handler</span><br></pre></td></tr></table></figure>
<h5 id="2-给符号赋值"><a href="#2-给符号赋值" class="headerlink" title="2. 给符号赋值"></a>2. 给符号赋值</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">symbol_name</span> = symbol_value</span><br><span class="line">或者<span class="meta">.set</span> symbol_name, symbol_value</span><br><span class="line">或者<span class="meta">.equ</span> symbol_name, symbol_value</span><br></pre></td></tr></table></figure>
<h5 id="3-符号名"><a href="#3-符号名" class="headerlink" title="3. 符号名"></a>3. 符号名</h5><ul>
<li>可由数字、字母或‘.’或‘_’组成，不可以数字开头，大小写敏感。</li>
</ul>
<h2 id="3、ARM汇编语言程序设计规范"><a href="#3、ARM汇编语言程序设计规范" class="headerlink" title="3、ARM汇编语言程序设计规范"></a>3、ARM汇编语言程序设计规范</h2><h3 id="（1）汇编器预定义的寄存器名称"><a href="#（1）汇编器预定义的寄存器名称" class="headerlink" title="（1）汇编器预定义的寄存器名称"></a>（1）汇编器预定义的寄存器名称</h3><img src="https://cdn.megalomania.icu/images/8319dfa3e428fed1c45fc10c279a5657.png">

<h3 id="（2）ARM汇编语言程序设计规范"><a href="#（2）ARM汇编语言程序设计规范" class="headerlink" title="（2）ARM汇编语言程序设计规范"></a>（2）ARM汇编语言程序设计规范</h3><ol>
<li>符号命名规则</li>
<li>注释</li>
<li>程序设计的其它要求</li>
</ol>
<h1 id="七、ARM汇编语言与嵌入式C混合编程"><a href="#七、ARM汇编语言与嵌入式C混合编程" class="headerlink" title="七、ARM汇编语言与嵌入式C混合编程"></a>七、ARM汇编语言与嵌入式C混合编程</h1><h2 id="1、嵌入式C编程规范"><a href="#1、嵌入式C编程规范" class="headerlink" title="1、嵌入式C编程规范"></a>1、嵌入式C编程规范</h2><ul>
<li>在当前的嵌入式开发中，嵌入式C语言是最为常见的程序设计语言。</li>
<li>优秀的代码还要具备<strong>易读性</strong>、<strong>易维护性</strong>、<strong>具有可移植</strong>和<strong>高可靠性</strong>。</li>
</ul>
<h3 id="（1）-嵌入式C程序书写规范"><a href="#（1）-嵌入式C程序书写规范" class="headerlink" title="（1） 嵌入式C程序书写规范"></a>（1） 嵌入式C程序书写规范</h3><ul>
<li><p>排版规则如下：    </p>
<ol>
<li><p>程序块要采用<strong>缩进风格</strong>编写</p>
</li>
<li><p><strong>较长的语句</strong>（例如超过80个字符）要<strong>分成多行书写</strong></p>
</li>
<li><p>循环、判断等语句中若<strong>有较长的表达式或语句</strong>，则要进行<strong>适应的划分</strong></p>
</li>
<li><p>若<strong>函数或过程中参数较长</strong>，也要进行适当的<strong>划分</strong>。</p>
</li>
<li><p>一般<strong>不要把多个短语句写在一行</strong>中</p>
</li>
<li><p>程序块的<strong>分界符语句的大括号“{”与“}”一般独占一行并且在同一列</strong></p>
</li>
</ol>
</li>
</ul>
<h3 id="（2）命名规则"><a href="#（2）命名规则" class="headerlink" title="（2）命名规则"></a>（2）命名规则</h3><ol>
<li>标识符的名称要简明，能够表达出确切的含义，可以使用<strong>完整的单词或通常可以理解的缩写</strong>。</li>
<li>如果在命名中使用特殊约定或缩写，则要进行注释说明。</li>
<li>对于变量命名，一般<strong>不取单个字符</strong> ,例如i、j、k…</li>
<li>函数名一般以大写字母开头；所有常量名字母统一用大写。</li>
</ol>
<h3 id="（3）注释说明"><a href="#（3）注释说明" class="headerlink" title="（3）注释说明"></a>（3）注释说明</h3><ul>
<li><p>注释有助于程序员理解程序的整体结构，也便于以后程序代码的维护与升级。常用的规则如下：    </p>
<ol>
<li><p>注释语言必须<strong>准确、简洁且容易理解</strong>;</p>
</li>
<li><p>程序代码<strong>源文件头部</strong>应进行注释说明 ;</p>
</li>
<li><p><strong>函数头部</strong>应进行注释；</p>
</li>
<li><p>程序中所用到的特定含义的<strong>常量、变量</strong>，在声明时都要加以注释 ；</p>
</li>
<li><p>对于<strong>宏定义、数据结构声明</strong>，如果其命名<strong>不是充分自注释</strong>的，也要加以注释。</p>
</li>
<li><p>如果注释单独占用一行，与其被注释的内容进行相同的缩进方式，一般将注释与其上面的代码用空行隔开</p>
</li>
<li><p>程序代码修改时，<strong>其注释也要及时修改</strong>，一定要保证代码与注释保持一致。</p>
</li>
</ol>
</li>
</ul>
<h2 id="2、嵌入式C程序设计中的位运算"><a href="#2、嵌入式C程序设计中的位运算" class="headerlink" title="2、嵌入式C程序设计中的位运算"></a>2、嵌入式C程序设计中的位运算</h2><ul>
<li>在嵌入式程序设计中，<strong>位操作</strong>是最常用的运算之一，因为在很多情况下要<strong>对寄存器中的某位或某个管脚进行操作</strong>，这些都需要用位操作来完成。</li>
</ul>
<h3 id="（1）按位与操作"><a href="#（1）按位与操作" class="headerlink" title="（1）按位与操作"></a>（1）按位与操作</h3><ul>
<li>按位与运算符“&amp;”是把参与运算的两个操作数所对应的各个二进制位进行按位相与。</li>
<li>只有当对应的两个二进制位全为1时，结果才为1，否则为0。</li>
<li>参与运算的两个操作数以<strong>补码形式</strong>出现。</li>
</ul>
<h3 id="（2）按位或操作"><a href="#（2）按位或操作" class="headerlink" title="（2）按位或操作"></a>（2）按位或操作</h3><ul>
<li>按位或操作运算符“|”是把参与运算的两个操作数对应的各个二进制位进行按位相或。</li>
<li>对应的两个二进制位中只要有一个为1，结果就为1，当两个对应的二进制位都为0时，结果位为0。</li>
<li>参与运算的两个操作数均以<strong>补码形式</strong>出现。</li>
</ul>
<h3 id="（3）按位异或操作"><a href="#（3）按位异或操作" class="headerlink" title="（3）按位异或操作"></a>（3）按位异或操作</h3><ul>
<li>按位异或运算符<strong>“^”</strong>是将参与运算的两个操作数对应的各个二进制位进行相异或。</li>
<li>当对应的两个二进制位<strong>相异</strong>时，结果位为1，相同时为0。</li>
<li>参与运算的两个操作数均以<strong>补码形式</strong>出现。</li>
</ul>
<h3 id="（4）取反操作"><a href="#（4）取反操作" class="headerlink" title="（4）取反操作"></a>（4）取反操作</h3><ul>
<li>取反运算符“<del>”实现对参与运算的操作数对应的各个二进制位按位求反。取反运算符“</del>”具有右结合性。所有1变为0，0变为1</li>
</ul>
<h3 id="（5）移位操作"><a href="#（5）移位操作" class="headerlink" title="（5）移位操作"></a>（5）移位操作</h3><ul>
<li>移位操作分为左移操作与右移操作。左移运算符“&lt;&lt;”实现将“&lt;&lt;”左边的操作数的各个二进制位向左移动“&lt;&lt;”右边操作数所指定的位数，高位丢弃，低位补0。</li>
<li>其值相当于<strong>乘以</strong>：<strong>2“左移位数”次方</strong>。</li>
<li>右移运算符“&gt;&gt;”实现将“&gt;&gt;”左边的操作数的各个二进制位向右移动“&gt;&gt;”右边操作数所指定的位数。</li>
<li>对于空位的补齐方式，无符号数与有符号数是有区别的。对无符号数进行右移时，低位丢弃，高位用0补齐，其值相当于<strong>除以</strong>：<strong>2“右移位数”次方</strong></li>
</ul>
<h2 id="3、嵌入式C程序设计中的几点说明"><a href="#3、嵌入式C程序设计中的几点说明" class="headerlink" title="3、嵌入式C程序设计中的几点说明"></a>3、嵌入式C程序设计中的几点说明</h2><h3 id="（1）volatile限制符"><a href="#（1）volatile限制符" class="headerlink" title="（1）volatile限制符"></a>（1）volatile限制符</h3><ul>
<li>volatile的本意为 “暂态的”或.“易变的”，该说明符起到<strong>抑制编译器优化</strong>的作用。</li>
<li>如果在声明时用“volatile”关键进行修饰，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供<strong>特殊地址的稳定访问</strong>。</li>
</ul>
<h3 id="（2）地址强制转换与多级指针"><a href="#（2）地址强制转换与多级指针" class="headerlink" title="（2）地址强制转换与多级指针"></a>（2）地址强制转换与多级指针</h3><h4 id="1-地址强制转换"><a href="#1-地址强制转换" class="headerlink" title="1* 地址强制转换"></a>1* 地址强制转换</h4><ul>
<li>在C程序设计中，绝对地址0x0FA00只是被当成一个整型数，如果要把它当成一个地址来使用就需要进行地址强制转换。</li>
<li>如定义一个整形指针int* p，然后把绝对地址0x0FA00转换成一个整形的地址值赋给这个整形指针，p = (int* )0x0FA00。</li>
<li>因此在嵌入式程序设计中，经常可以可以看到寄存器用如下方式进行定义：</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define rPCONA	<span class="comment">(*(volatile unsigned *)</span><span class="number">0</span>x1D20000)</span><br><span class="line">#define rPDATA	<span class="comment">(*(volatile unsigned *)</span><span class="number">0</span>x1D20004)</span><br></pre></td></tr></table></figure>
<h4 id="2-多级指针"><a href="#2-多级指针" class="headerlink" title="2* 多级指针"></a>2* 多级指针</h4><img src="https://cdn.megalomania.icu/images/8870b8c26a8c27006f3c7d934b35dc04.png">

<h3 id="（3）预处理的使用"><a href="#（3）预处理的使用" class="headerlink" title="（3）预处理的使用"></a>（3）预处理的使用</h3><ul>
<li>在源流程序被编译器处理之前, 编译预处理器首先对源程序中的预处理命令进行展开或处理。</li>
<li>预处理命令书写格式为以“#”开头，占单独书写行，语句尾不加分号。</li>
</ul>
<h4 id="1-宏定义-define"><a href="#1-宏定义-define" class="headerlink" title="1* 宏定义(#define)"></a>1* 宏定义(#define)</h4><h5 id="1-不带参数的宏"><a href="#1-不带参数的宏" class="headerlink" title="1. 不带参数的宏"></a>1. 不带参数的宏</h5><ul>
<li>不带参数的宏定义的一般形式为：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 [宏体]</span></span><br></pre></td></tr></table></figure>
<h5 id="2-带参数的宏定义"><a href="#2-带参数的宏定义" class="headerlink" title="2. 带参数的宏定义"></a>2. 带参数的宏定义</h5><ul>
<li>带参数的宏定义一般形式为：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名(参数表) 宏体</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.megalomania.icu/images/a3350d706af9cb82c9cf29e6cfe2377d.png">

<h5 id="3-带参宏与函数的区别"><a href="#3-带参宏与函数的区别" class="headerlink" title="3. 带参宏与函数的区别"></a>3. 带参宏与函数的区别</h5><img src="https://cdn.megalomania.icu/images/0b69547b3eadc44a896ece257c1b405e.png">

<h4 id="2-文件包含-include"><a href="#2-文件包含-include" class="headerlink" title="2* 文件包含(#include)"></a>2* 文件包含(#include)</h4><ul>
<li>文件包含的功能是使得一个源文件可以将另一个源文件的内容全部包含进来，它的一般形式为：</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “文件名”	//先搜索当前目录，再搜索标准目录，可以指定目录</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;文件名&gt;</span>	//直接按标准目录搜索</span></span><br></pre></td></tr></table></figure>
<h4 id="3-条件编译"><a href="#3-条件编译" class="headerlink" title="3* 条件编译"></a>3* 条件编译</h4><h5 id="1-形式1"><a href="#1-形式1" class="headerlink" title="1. 形式1"></a>1. 形式1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<h5 id="2-形式2"><a href="#2-形式2" class="headerlink" title="2. 形式2"></a>2. 形式2</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 标识符</span></span><br><span class="line">		程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<h5 id="3-形式3"><a href="#3-形式3" class="headerlink" title="3. 形式3"></a>3. 形式3</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 表达式1</span></span><br><span class="line">		程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 表达式2</span></span><br><span class="line">		程序段<span class="number">2</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">       程序段<span class="number">3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="4、嵌入式C程序设计格式"><a href="#4、嵌入式C程序设计格式" class="headerlink" title="4、嵌入式C程序设计格式"></a>4、嵌入式C程序设计格式</h2><h3 id="（1）可重入函数"><a href="#（1）可重入函数" class="headerlink" title="（1）可重入函数"></a>（1）可重入函数</h3><ul>
<li>如果某个函数可以被多个任务并发使用，而不会造成数据错误，我们就说这个函数具有<strong>可重入性（reentrant）</strong> 。</li>
<li>可重入函数可以<strong>使用局部变量</strong>，也可以使用全局变量。</li>
<li>如果<strong>使用全局变量</strong>，则应通过关中断、信号量（即P、V操作）等手段<strong>对其加以保护</strong></li>
</ul>
<h3 id="（2）中断处理程序"><a href="#（2）中断处理程序" class="headerlink" title="（2）中断处理程序"></a>（2）中断处理程序</h3><ul>
<li><p>在编写中断服务程序时需要满足如下要求：   </p>
<ol>
<li><p>不能向中断服务程序传递参数；</p>
</li>
<li><p>中断服务程序没有返回值；</p>
</li>
<li><p>中断服务程序应要尽可能短，来减少中断服务程序的处理时间，保证实时系统的性能。</p>
</li>
</ol>
</li>
</ul>
<h3 id="（3）模块化程序设计"><a href="#（3）模块化程序设计" class="headerlink" title="（3）模块化程序设计"></a>（3）模块化程序设计</h3><ul>
<li>嵌入式C程序设计主要采用模块化设计方法，将系统内的任务进行合理的划分，将具有同一属性或相同类别的代码归为一类组成模块，每个模块的功能相对独立。</li>
<li>将整个软件系统分为多个模块，编程思路就会很清晰。<img src="https://cdn.megalomania.icu/images/4f8d828e18a1125f76eff5a12bf4e5f0.png">

</li>
</ul>
<h2 id="5、过程调用标准ATPCS与AAPCS"><a href="#5、过程调用标准ATPCS与AAPCS" class="headerlink" title="5、过程调用标准ATPCS与AAPCS"></a>5、过程调用标准ATPCS与AAPCS</h2><ul>
<li>过程调用标准ATPCS（ARM-Thumb Produce Call Standard）规定了子程序间相互调用的基本规则， ATPCS规定子程序调用过程中寄存器的使用规则、数据栈的使用规则及参数的传递规则。</li>
<li>2007年，ARM公司推出了新的过程调用标准AAPCS（ARM Architecture Produce Call Standard）,它只是改进了原有的ATPCS的二进制代码的兼容性。</li>
<li>2011年，ARM公司推出了新的过程调用标准AAPCS64（ARM Architecture Produce Call Standard）,针对64位架构AArch64</li>
</ul>
<h3 id="（1）寄存器使用规则"><a href="#（1）寄存器使用规则" class="headerlink" title="（1）寄存器使用规则"></a>（1）寄存器使用规则</h3><ol>
<li>子程序间通过寄存器R0～R3传递参数，寄存器R0～R3可记作A1～A4。被调用的子程序在返回前无须恢复寄存器R0～R3的内容。</li>
<li>在子程序中，ARM状态下使用寄存器R4～R11来保存局部变量，寄存器R4～R11可记作V1～V8；Thumb状态下只能使用R4～R7来保存局部变量。</li>
<li>寄存器R12用作子程序间调用时临时保存栈指针，函数返回时使用该寄存器进行出栈，记作IP；在子程序间的链接代码中常有这种使用规则。</li>
<li>通用寄存器R13用作数据栈指针，记作SP。</li>
<li>通用寄存器R14用作链接寄存器 ；</li>
<li>通用寄存器R15用作程序计数器，记作PC 。</li>
</ol>
<h3 id="（2）数据栈使用规则"><a href="#（2）数据栈使用规则" class="headerlink" title="（2）数据栈使用规则"></a>（2）数据栈使用规则</h3><ul>
<li>过程调用标准规定数据栈为FD类型，并且对数据栈的操作时要求8字节对齐的。</li>
<li>堆栈是一种数据结构</li>
<li>先进先出</li>
<li>使用一个堆栈指针的专用寄存器只是当前位置    * ARM 中是R13</li>
</ul>
<h4 id="1-堆栈分类"><a href="#1-堆栈分类" class="headerlink" title="1* 堆栈分类"></a>1* 堆栈分类</h4><ul>
<li><p><strong>根据堆栈指针的位置可以分为</strong>：    </p>
<ol>
<li><p>满堆栈（Full Stack）：    </p>
<ul>
<li>当堆栈指针指向最后压入堆栈的数据时；</li>
</ul>
</li>
<li><p>空堆栈（Empty Stack）：    </p>
<ul>
<li>当堆栈指针指向下一个将要放入数据的空位置时；</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>根据堆栈的生成方式，又可以分为递增堆栈和递减堆栈</strong>：    </p>
<ol>
<li><p>递增堆栈（Ascending Stack） ：    </p>
<ul>
<li>当堆栈由低地址向高地址生成时；</li>
</ul>
</li>
<li><p>递减堆栈（Decending Stack） ：    </p>
<ul>
<li>当堆栈由高地址向低地址生成时；</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-块拷贝与栈操作的对应关系"><a href="#2-块拷贝与栈操作的对应关系" class="headerlink" title="2* 块拷贝与栈操作的对应关系"></a>2* 块拷贝与栈操作的对应关系</h4><img src="https://cdn.megalomania.icu/images/2b93e4faa9c07b751567db82537eb141.png">

<h3 id="（3）参数传递规则"><a href="#（3）参数传递规则" class="headerlink" title="（3）参数传递规则"></a>（3）参数传递规则</h3><h4 id="1-参数个数可变的子程序参数传递规则"><a href="#1-参数个数可变的子程序参数传递规则" class="headerlink" title="1* 参数个数可变的子程序参数传递规则"></a>1* 参数个数可变的子程序参数传递规则</h4><ul>
<li>对于参数个数可变的子程序，当参数个数不超过4个时，可以使用寄存器R0～R3来传递；当参数个数超过4个时，还可以使用数据栈进行参数传递。</li>
</ul>
<h4 id="2-参数个数固定的子程序参数传递规则"><a href="#2-参数个数固定的子程序参数传递规则" class="headerlink" title="2* 参数个数固定的子程序参数传递规则"></a>2* 参数个数固定的子程序参数传递规则</h4><ul>
<li>如果系统不包含浮点运算的硬件部件且没有浮点参数时，则依次将各参数传送到寄存器R0～R3中，如果参数个数多于4个，将剩余的字数据通过数据栈来传递；</li>
<li>如果包括浮点参数则要通过相应的规则将浮点参数转换为整数参数，然后依次将各参数传送到寄存器R0～R3中。如果参数多于4个，将剩余字数据传送到数据栈中，入栈的顺序与参数顺序相反，即最后一个字数据先入栈。</li>
<li>如果系统包含浮点运算的硬件部件，将按照如下规则传递：    <ul>
<li>各个浮点参数按顺序处理</li>
<li>为每个浮点参数分配寄存器。分配方法是：找到编号最小的满足该浮点参数需要的一组连续的FP寄存器进行参数传递。</li>
</ul>
</li>
</ul>
<h4 id="3-子程序结果返回规则"><a href="#3-子程序结果返回规则" class="headerlink" title="3* 子程序结果返回规则"></a>3* 子程序结果返回规则</h4><ol>
<li>结果为一个32位的整数时，通过寄存器R0返回；结果为一个64位整数时，通过寄存器R0，R1返回。</li>
<li>结果为一个浮点数时，可以通过浮点运算部件的寄存器F0、D0或者S0来返回；结果为复合型的浮点数（如复数）时，可以通过寄存器F0～Fn或者Ｄ0～Ｄn来返回。</li>
<li>对于位数更多的结果，需要通过内存来传递。</li>
</ol>
<h2 id="6、ARM汇编语言与嵌入式C混合编程"><a href="#6、ARM汇编语言与嵌入式C混合编程" class="headerlink" title="6、ARM汇编语言与嵌入式C混合编程"></a>6、ARM汇编语言与嵌入式C混合编程</h2><ul>
<li>在嵌入式程序设计中，有些场合（如对具体的硬件资源进行访问）必须用汇编语言来实现，可以采用在嵌入式C语言程序中嵌入汇编语言或嵌入式C语言调用汇编语言来实现。</li>
</ul>
<h3 id="（1）内嵌汇编"><a href="#（1）内嵌汇编" class="headerlink" title="（1）内嵌汇编"></a>（1）内嵌汇编</h3><h4 id="1-ARM开发工具编译环境下内嵌汇编语法格式"><a href="#1-ARM开发工具编译环境下内嵌汇编语法格式" class="headerlink" title="1* ARM开发工具编译环境下内嵌汇编语法格式"></a>1* ARM开发工具编译环境下内嵌汇编语法格式</h4><img src="https://cdn.megalomania.icu/images/25471652dbabc9b2829fb34b1681407b.png">

<h4 id="2-GNU-ARM环境下内嵌汇编语法格式"><a href="#2-GNU-ARM环境下内嵌汇编语法格式" class="headerlink" title="2* GNU ARM环境下内嵌汇编语法格式"></a>2* GNU ARM环境下内嵌汇编语法格式</h4><img src="https://cdn.megalomania.icu/images/669d643efde561a1a809e0086f45f6eb.png">

<h4 id="3-内嵌汇编的局限性"><a href="#3-内嵌汇编的局限性" class="headerlink" title="3* 内嵌汇编的局限性"></a>3* 内嵌汇编的局限性</h4><ul>
<li>ARM开发工具编译环境下内嵌汇编语言，指令操作数可以是寄存器、常量或C语言表达式。可以是char、short或int类型，而且是作为无符号数进行操作。</li>
<li>当表达式过于复杂时需要使用较多的物理寄存器，有可能产生冲突。</li>
<li>GNU ARM编译环境下内嵌汇编语言ARM开发工具稍有差别，不能直接引用C语言中的变量。</li>
</ul>
<h5 id="1-物理寄存器"><a href="#1-物理寄存器" class="headerlink" title="1. 物理寄存器"></a>1. 物理寄存器</h5><ul>
<li>不要直接向程序计数器PC赋值，程序的跳转只能通过B或BL指令实现。</li>
<li>一般将寄存器R0～R3、R12及R14用于子程序调用存放中间结果，因此在内嵌汇编指令中，一般不要将这些寄存器同时指定为指令中的物理寄存器。</li>
<li>在内嵌的汇编指令中使用物理寄存器时，如果有C语言变量使用了该物理寄存器，则编译器将在合适的时候保存并恢复该变量的值。需要注意的是，当寄存器SP、SL、FP以及SB用作特定的用途时，编译器不能恢复这些寄存器的值。</li>
<li>通常在内嵌汇编指令中不要指定物理寄存器，因为有可能会影响编译器分配寄存器，进而可能影响代码的效率。</li>
</ul>
<h5 id="2-标号、常量及指令展开"><a href="#2-标号、常量及指令展开" class="headerlink" title="2. 标号、常量及指令展开"></a>2. 标号、常量及指令展开</h5><ul>
<li>C语言程序中的标号可以被内嵌的汇编指令所使用。但是只有B指令可以使用C语言程序中的标号，BL指令不能使用C语言程序中的标号。</li>
</ul>
<h5 id="3-内存单元的分配"><a href="#3-内存单元的分配" class="headerlink" title="3. 内存单元的分配"></a>3. 内存单元的分配</h5><ul>
<li>内嵌汇编器不支持汇编语言中用于内存分配的伪操作。所用的内存单元的分配都是通过C语言程序完成的，分配的内存单元通过变量以供内嵌的汇编器使用。</li>
</ul>
<h5 id="4-SWI和BL指令"><a href="#4-SWI和BL指令" class="headerlink" title="4. SWI和BL指令"></a>4. SWI和BL指令</h5><ul>
<li>SWI和BL指令用于内嵌汇编时，除了正常的操作数域外，还必须增加如下3个可选的寄存器列表：</li>
<li>用于存放输入的参数的寄存器列表。</li>
<li>用于存放返回结果的寄存器列表。</li>
<li>用于保存被调用的子程序工作寄存器的寄存器列表。</li>
</ul>
<h4 id="4-内嵌汇编器与armasm汇编器的区别"><a href="#4-内嵌汇编器与armasm汇编器的区别" class="headerlink" title="4* 内嵌汇编器与armasm汇编器的区别"></a>4* 内嵌汇编器与armasm汇编器的区别</h4><ul>
<li>内嵌汇编器不支持“LDR Rn, = expression”伪指令，使用“MOV Rn, expression”代替，不支持ADR、ADRL伪指令</li>
<li>十六进制数前要使用前缀0x，不能使用&amp;。当使用8位移位常量导致CPSR中的ALU标志位需要更新时，N、Z、C、V标志中的C不具有实际意义</li>
<li>指令中使用的C变量不能与任何物理寄存器同名，否则会造成混乱</li>
<li>不支持BX和BLX指令</li>
<li>使用内嵌汇编器，不能通过对程序计数器PC赋值，实现程序返回或跳转。</li>
<li>编译器可能使用寄存器R0～R3、R12及R14存放中间结果，如果使用这些寄存器时要特别注意。</li>
</ul>
<h3 id="（3）ARM汇编语言与嵌入式C程序相互调用"><a href="#（3）ARM汇编语言与嵌入式C程序相互调用" class="headerlink" title="（3）ARM汇编语言与嵌入式C程序相互调用"></a>（3）ARM汇编语言与嵌入式C程序相互调用</h3><h4 id="1-汇编程序调用C程序"><a href="#1-汇编程序调用C程序" class="headerlink" title="1* 汇编程序调用C程序"></a>1* 汇编程序调用C程序</h4><ul>
<li>在GNU ARM编译环境下，汇编程序中要使用.extern伪操作声明将要调用的C程序；</li>
<li>在ARM开发工具编译环境下，汇编程序中要使用IMPORT伪操作声明将要调用的C程序。</li>
</ul>
<h4 id="2-C程序调用汇编程序"><a href="#2-C程序调用汇编程序" class="headerlink" title="2* C程序调用汇编程序"></a>2* C程序调用汇编程序</h4><ul>
<li>在GNU ARM编译环境下，在汇编程序中要使用.global伪操作声明汇编程序为全局的函数，可被外部函数调用，同时在C程序中要用关键字extern声明要调用的汇编语言程序。</li>
<li>在ARM开发工具编译环境下，汇编程序中要使用EXPORT伪操作声明本程序可以被其他程序调用。同时也要在C程序中要用关键字extern声明要调用的汇编语言程序。</li>
</ul>
<h1 id="八、S3C44B0-S3C2410通信与LCD接口技术"><a href="#八、S3C44B0-S3C2410通信与LCD接口技术" class="headerlink" title="八、S3C44B0/S3C2410通信与LCD接口技术"></a>八、S3C44B0/S3C2410通信与LCD接口技术</h1><h2 id="S3C44B0-S3C2410-UART"><a href="#S3C44B0-S3C2410-UART" class="headerlink" title="S3C44B0/ S3C2410 UART"></a>S3C44B0/ S3C2410 UART</h2><ul>
<li>通用异步接收和发送UART（Universal Asynchronous Receiver and Transmitter）协议作为一种低速通信协议,广泛应用于通信领域的各种场合。</li>
</ul>
<h3 id="（1）UART原理"><a href="#（1）UART原理" class="headerlink" title="（1）UART原理"></a>（1）UART原理</h3><h4 id="1-串行通信的工作方式"><a href="#1-串行通信的工作方式" class="headerlink" title="1* 串行通信的工作方式"></a>1* 串行通信的工作方式</h4><img src="https://cdn.megalomania.icu/images/26705ad147e606394f0ecabbc14b4657.png">

<h4 id="2-串行通信的波特率"><a href="#2-串行通信的波特率" class="headerlink" title="2* 串行通信的波特率"></a>2* 串行通信的波特率</h4><ul>
<li>在串行通信中，用波特率来描述数据的传输速度。波特率是每秒钟传送的二进制位数，其单位是bps(bits per second)。</li>
<li>是衡量串行数据速度快慢的重要指标。异步串行通信要求通信双方的波特率必须相同。</li>
</ul>
<h4 id="3-奇偶校验"><a href="#3-奇偶校验" class="headerlink" title="3* 奇偶校验"></a>3* 奇偶校验</h4><ul>
<li>在发送数据时，每个数据后要附加1个奇偶校验位，这个校验位可以为1也可以为0，用来保证包括奇偶校验位在内的所有传输的数据帧中1的的个数为奇数（奇校验）或1的个数为偶数（偶校验）。</li>
</ul>
<h4 id="4-数据帧格式"><a href="#4-数据帧格式" class="headerlink" title="4* 数据帧格式"></a>4* 数据帧格式</h4><img src="https://cdn.megalomania.icu/images/d95660ba952372d85307c365593f580b.png">

<img src="https://cdn.megalomania.icu/images/8db994056da6ef4a4cd45dd05e7881f4.png">

<h3 id="（2）S3C44B0-S3C2410-UART模块"><a href="#（2）S3C44B0-S3C2410-UART模块" class="headerlink" title="（2）S3C44B0/ S3C2410 UART模块"></a>（2）S3C44B0/ S3C2410 UART模块</h3><ul>
<li>S3C44B0的UART单元提供两个独立异步串行I/O（SIO）端口，S3C2410的UART提供3个独立异步串行I/O，每一个可以在基于中断和基于DMA的模式下操作。</li>
<li>S3C44B0的UART可以支持位速率高达115.2K bps，S3C2410的UART可支持高达230.4K bps。每个UART通道包含两个16字节先进先出缓存（FIFO），负责数据的接收和发送。</li>
</ul>
<h3 id="（3）S3C44B0-S3C2410-UART操作"><a href="#（3）S3C44B0-S3C2410-UART操作" class="headerlink" title="（3）S3C44B0/ S3C2410 UART操作"></a>（3）S3C44B0/ S3C2410 UART操作</h3><h4 id="1-数据发送与接收"><a href="#1-数据发送与接收" class="headerlink" title="1* 数据发送与接收"></a>1* 数据发送与接收</h4><ul>
<li>它包括一个起始位，5<del>8个数据位，一个可选的奇偶校验位和1</del>2个停止位，用户可以通过线控制寄存器（ULCONn）的编程来设定。</li>
<li>在数据传输完成后产生传输中止信号，在中止信号传输后，可以继续向Tx FIFO（或在非FIFO模式下的Tx 保持寄存器）中发送数据。</li>
</ul>
<h4 id="2-自动流量控制（AFC）"><a href="#2-自动流量控制（AFC）" class="headerlink" title="2* 自动流量控制（AFC）"></a>2* 自动流量控制（AFC）</h4><ul>
<li>S3C44B0和S3C2410支持带有nRTS和nCTS信号的自动流量控制。如果希望连接UART到调制解调器，禁止UMCONn寄存器的自动流量控制位，然后通过软件控制nRTS的信号。<img src="https://cdn.megalomania.icu/images/4ba0649791083ef923428cfaa9acdb2c.png">

</li>
</ul>
<h4 id="3-自环模式"><a href="#3-自环模式" class="headerlink" title="3* 自环模式"></a>3* 自环模式</h4><ul>
<li>S3C44B0/S3C2410提供一个测试模式称为自环模式，以解决在通信连接时的错误。在此模式下，发送的数据被直接接收。</li>
</ul>
<h4 id="4-红外模式"><a href="#4-红外模式" class="headerlink" title="4* 红外模式"></a>4* 红外模式</h4><ul>
<li><p>S3C44B0/S3C2410的UART模块支持红外（IR）发送和接收，可以通过设置UART控制寄存器中的红外模式位选定</p>
<img src="https://cdn.megalomania.icu/images/4d5ce695eeb583720f583ee715ff8482.png">
</li>
<li><p>当IR处于发送模式时，如果输送的的数据位为0，传输周期是正常串口传输的3/16脉冲；当IR处于接收模式时，接收器必须侦测3/16脉冲周期来识别一个0值。</p>
</li>
</ul>
<h3 id="（4）UART中断与波特率的计算"><a href="#（4）UART中断与波特率的计算" class="headerlink" title="（4）UART中断与波特率的计算"></a>（4）UART中断与波特率的计算</h3><h4 id="1-UART中断"><a href="#1-UART中断" class="headerlink" title="1* UART中断"></a>1* UART中断</h4><ul>
<li>S3C44B0/S3C2410每个UART有7个状态信号：超时错误、奇偶错误、帧错误、通信中止、接收数据缓冲区就绪、发送数据缓冲区为空和发送移位寄存器为空</li>
</ul>
<h4 id="2-波特率的产生"><a href="#2-波特率的产生" class="headerlink" title="2* 波特率的产生"></a>2* 波特率的产生</h4><img src="https://cdn.megalomania.icu/images/b8247a234ebb00af85a314d37bbb6000.png">

<h3 id="（5）S3C44B0-S3C2410-UART专用功能寄存器"><a href="#（5）S3C44B0-S3C2410-UART专用功能寄存器" class="headerlink" title="（5）S3C44B0/ S3C2410 UART专用功能寄存器"></a>（5）S3C44B0/ S3C2410 UART专用功能寄存器</h3><h4 id="1-UART线控制寄存器-ULCONn"><a href="#1-UART线控制寄存器-ULCONn" class="headerlink" title="1* UART线控制寄存器(ULCONn)"></a>1* UART线控制寄存器(ULCONn)</h4><ul>
<li><p>S3C44B0有2个UART线控制寄存器，ULCON0和ULCON1。</p>
</li>
<li><p>S3C2410有三个UART控制寄存器，ULCON0，ULCON1和ULCON2。</p>
<img src="https://cdn.megalomania.icu/images/49f8e8d1a8a1521c2776c5802b2180b3.png">

<img src="https://cdn.megalomania.icu/images/e1a86fbe2bb55347323298bf7a97f313.png">

</li>
</ul>
<h4 id="2-UART控制寄存器UCONn"><a href="#2-UART控制寄存器UCONn" class="headerlink" title="2* UART控制寄存器UCONn"></a>2* UART控制寄存器UCONn</h4><ul>
<li><p>S3C44B0有2个UART控制寄存器：UCON0和UCON1。</p>
</li>
<li><p>S3C2410有三个UART控制寄存器：UCON0，UCON1和UCON2。</p>
<img src="https://cdn.megalomania.icu/images/7d856c22a71503a06f1831b694547843.png">

<img src="https://cdn.megalomania.icu/images/0c975797c4859a504000e6b0f7b1bce6.png">

</li>
</ul>
<h4 id="3-UART-FIFO控制寄存器"><a href="#3-UART-FIFO控制寄存器" class="headerlink" title="3* UART FIFO控制寄存器"></a>3* UART FIFO控制寄存器</h4><ul>
<li><p>S3C44B0有2个UART FIFO控制寄存器：UFCON0和UFCON1。</p>
</li>
<li><p>S3C2410有3个UART FIFO控制寄存器：UFCON0，UFCON1和UFCON2。</p>
<img src="https://cdn.megalomania.icu/images/66e8e0a6e442226d74db9b0c6cb5e612.png">

<img src="https://cdn.megalomania.icu/images/9fcebd9adcf3923ae21b72afecf3a2b0.png">

</li>
</ul>
<h4 id="4-UART调制解调器控制寄存器"><a href="#4-UART调制解调器控制寄存器" class="headerlink" title="4* UART调制解调器控制寄存器"></a>4* UART调制解调器控制寄存器</h4><ul>
<li>S3C44B0有2个UART调制解调器控制寄存器，UMCON0和UMCON1。</li>
<li>S3C2410有3个UART调制解调器控制寄存器：UMCON0，UMCON1和UMCON2。</li>
</ul>
<h4 id="5-UART-发送-接收状态寄存器"><a href="#5-UART-发送-接收状态寄存器" class="headerlink" title="5* UART 发送/接收状态寄存器"></a>5* UART 发送/接收状态寄存器</h4><ul>
<li><p>S3C44B0有2个UART发送/接收状态寄存器：UTRSTAT0和UTRSTAT1。</p>
</li>
<li><p>S3C2410有3个UART发送/接收状态寄存器：UTRSTAT0，UTRSTAT1和UTRSTAT2。</p>
<img src="https://cdn.megalomania.icu/images/4c275a98af46977eb02b11d46cecde9f.png">

<img src="https://cdn.megalomania.icu/images/d1bf181863645a83d93ee7eb94aafaaa.png">

</li>
</ul>
<h4 id="6-UART错误状态寄存器"><a href="#6-UART错误状态寄存器" class="headerlink" title="6* UART错误状态寄存器"></a>6* UART错误状态寄存器</h4><ul>
<li>S3C44B0有2个UART错误状态寄存器：UERSTAT0和UERSTAT1。</li>
<li>S3C2410有3个UART错误状态寄存器：UERSTAT0，UERSTAT1和UERSTAT2</li>
</ul>
<h4 id="7-UART-FIFO状态寄存器"><a href="#7-UART-FIFO状态寄存器" class="headerlink" title="7* UART FIFO状态寄存器"></a>7* UART FIFO状态寄存器</h4><ul>
<li><p>S3C44B0有2个UART FIFO状态寄存器：UFSTAT0和UFSTAT1。</p>
</li>
<li><p>S3C2410有3个UART FIFO状态寄存器：UFSTAT0，UFSTAT1和UFSTAT2。</p>
<img src="https://cdn.megalomania.icu/images/569323c30cf2528416df71f55d637e42.png">

<img src="https://cdn.megalomania.icu/images/f35c79457aecb931b880bd74a7a1b5c2.png">

</li>
</ul>
<h4 id="8-UART-调制解调器状态寄存器"><a href="#8-UART-调制解调器状态寄存器" class="headerlink" title="8* UART 调制解调器状态寄存器"></a>8* UART 调制解调器状态寄存器</h4><ul>
<li>S3C44B0有2个UART调制解调器状态寄存器：UMSTAT0和UMSTAT1。</li>
<li>S3C2410也有2个UART调制解调器状态寄存器：UMSTAT0和UMSTAT1</li>
</ul>
<h4 id="9-UART-发送缓冲寄存器"><a href="#9-UART-发送缓冲寄存器" class="headerlink" title="9* UART 发送缓冲寄存器"></a>9* UART 发送缓冲寄存器</h4><ul>
<li><p>S3C44B0有2个UART发送缓冲寄存器：UTXH0和UTXH1。</p>
</li>
<li><p>S3C2410也有3个UART发送缓冲寄存器：UTXH0、UTXH1和UTXH2。</p>
<img src="https://cdn.megalomania.icu/images/928feeb718b34f6048991a6596772322.png">

<img src="https://cdn.megalomania.icu/images/dcc17685b55dcb19f010ba839fc7c6a2.png">

</li>
</ul>
<h4 id="10-UART-接收缓冲寄存器"><a href="#10-UART-接收缓冲寄存器" class="headerlink" title="10* UART 接收缓冲寄存器"></a>10* UART 接收缓冲寄存器</h4><ul>
<li><p>S3C44B0有2个UART发送缓冲寄存器：URXH0和URXH1。</p>
</li>
<li><p>S3C2410也有3个UART发送缓冲寄存器：URXH0、URXH1和URXH2。</p>
<img src="https://cdn.megalomania.icu/images/0b7a9e4913027782d17afec5870e4504.png">

<img src="https://cdn.megalomania.icu/images/6fdb4274025c34ce098315a0dcf930fc.png">

</li>
</ul>
<h1 id="九、实验源码"><a href="#九、实验源码" class="headerlink" title="九、实验源码"></a>九、实验源码</h1><ol>
<li>对内存地址0X3000开始的100个字内单元填⼊0X10000001—-0X10000064,将每个字单元进⾏64位累加，结果送⼊其后容闲内存单元</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">       <span class="meta">AREA</span> exp,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line">       <span class="meta">ENTRY</span></span><br><span class="line">       <span class="meta">CODE32</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">START</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="number">#0x3000</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R1</span>,<span class="number">#0x10000001</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R2</span>,<span class="number">#0x64</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">LOOP1</span></span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>],<span class="number">#4</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#1</span></span><br><span class="line">       <span class="keyword">SUBS</span> <span class="built_in">R2</span>,<span class="built_in">R2</span>,<span class="number">#1</span></span><br><span class="line">       <span class="keyword">BNE</span> LOOP1</span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="number">#0x3000</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R2</span>,<span class="number">#0x64</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R4</span>,<span class="number">#0</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R3</span>,<span class="number">#0</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">LOOP2</span></span><br><span class="line">       <span class="keyword">LDR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>],<span class="number">#4</span></span><br><span class="line">       <span class="keyword">ADDS</span> <span class="built_in">R3</span>,<span class="built_in">R1</span>,<span class="built_in">R3</span></span><br><span class="line">       <span class="keyword">ADC</span> <span class="built_in">R4</span>,<span class="built_in">R4</span>,<span class="number">#0</span></span><br><span class="line">       <span class="keyword">SUBS</span> <span class="built_in">R2</span>,<span class="built_in">R2</span>,<span class="number">#1</span></span><br><span class="line">       <span class="keyword">BNE</span> LOOP2</span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R3</span>,[<span class="built_in">R0</span>],<span class="number">#4</span></span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R4</span>,[<span class="built_in">R0</span>],<span class="number">#4</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">STOP</span></span><br><span class="line">       <span class="keyword">B</span> STOP</span><br><span class="line">       <span class="meta">END</span></span><br></pre></td></tr></table></figure>
<hr>
<p>​    2. 实现整数除法123/22，得出商和余数。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       <span class="meta">AREA</span> exp,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line">       <span class="meta">ENTRY</span></span><br><span class="line">       <span class="meta">CODE32</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">START</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="number">#123</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R1</span>,<span class="number">#22</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R2</span>,<span class="number">#0</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">LOOP</span></span><br><span class="line">       <span class="keyword">SUB</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="built_in">R1</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R2</span>,<span class="built_in">R2</span>,<span class="number">#1</span></span><br><span class="line">       <span class="keyword">CMP</span> <span class="built_in">R0</span>,<span class="built_in">R1</span></span><br><span class="line">       <span class="keyword">BCS</span> LOOP</span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R3</span>,<span class="built_in">R0</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">STOP</span></span><br><span class="line">       <span class="keyword">B</span> STOP</span><br><span class="line">       <span class="meta">END</span></span><br></pre></td></tr></table></figure>
<hr>
<p>​    3. 将R0中的数据调换顺序    * 例如： R0=0xAABBCCDD调换顺序后R0＝0xDDCCBBAA</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">       AREA exp,CODE,READONLY</span><br><span class="line">       ENTR</span><br><span class="line">       CODE32</span><br><span class="line">       </span><br><span class="line">START</span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="meta">#0xAA000000</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="meta">#0xBB0000</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="meta">#0xCC00</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="meta">#0xDD</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">AND</span> <span class="built_in">R1</span>,<span class="built_in">R0</span>,<span class="meta">#0xFF000000</span></span><br><span class="line">       <span class="keyword">AND</span> <span class="built_in">R2</span>,<span class="built_in">R0</span>,<span class="meta">#0x00FF0000</span></span><br><span class="line">       <span class="keyword">AND</span> <span class="built_in">R3</span>,<span class="built_in">R0</span>,<span class="meta">#0x0000FF00</span></span><br><span class="line">       <span class="keyword">AND</span> <span class="built_in">R4</span>,<span class="built_in">R0</span>,<span class="meta">#0x000000FF</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="keyword">LSR</span> <span class="meta">#24</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R2</span>,<span class="built_in">R2</span>,<span class="keyword">LSR</span> <span class="meta">#8</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R3</span>,<span class="built_in">R3</span>,<span class="keyword">LSL</span> <span class="meta">#8</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R4</span>,<span class="built_in">R4</span>,<span class="keyword">LSL</span> <span class="meta">#24</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="meta">#0</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="built_in">R1</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="built_in">R2</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="built_in">R3</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="built_in">R4</span></span><br><span class="line">       </span><br><span class="line">STOP</span><br><span class="line">       B STOP</span><br><span class="line">       END</span><br></pre></td></tr></table></figure>
<hr>
<p>​    4. 将整数数组 {0xAABBCC11,0xAABBCC00,0xAABBC</p>
<p>C33,0xAABBCC22,0xAABBCC44}进⾏选择排序。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">       <span class="meta">AREA</span> exp,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line">       <span class="meta">ENTRY</span></span><br><span class="line">       <span class="meta">CODE32</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">START</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="number">#0</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R1</span>,<span class="number">#0xAA000000</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#0xBB0000</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#0xCC00</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#0x11</span></span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>]</span><br><span class="line">       <span class="keyword">SUB</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#0x11</span></span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>,<span class="number">#4</span>]!</span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#0x33</span></span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>,<span class="number">#4</span>]!</span><br><span class="line">       <span class="keyword">SUB</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#0x11</span></span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>,<span class="number">#4</span>]!</span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#0x22</span></span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R1</span>,[<span class="built_in">R0</span>,<span class="number">#4</span>]!</span><br><span class="line">      </span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R1</span>,<span class="number">#16</span></span><br><span class="line">       </span><br><span class="line"><span class="symbol">LOOP1</span></span><br><span class="line">       <span class="keyword">CMP</span> <span class="built_in">R1</span>,<span class="number">#0</span></span><br><span class="line">       <span class="keyword">BEQ</span> STOP</span><br><span class="line">       <span class="keyword">LDR</span> <span class="built_in">R2</span>,[<span class="built_in">R1</span>]</span><br><span class="line">       <span class="keyword">SUB</span> <span class="built_in">R4</span>,<span class="built_in">R1</span>,<span class="number">#4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LOOP2</span></span><br><span class="line">       <span class="keyword">LDR</span> <span class="built_in">R3</span>,[<span class="built_in">R4</span>],#-<span class="number">4</span></span><br><span class="line">       <span class="keyword">CMP</span> <span class="built_in">R2</span>,<span class="built_in">R3</span></span><br><span class="line">       <span class="keyword">BCS</span> JUMP</span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">R2</span>,<span class="built_in">R3</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">R5</span>,<span class="built_in">R4</span>,<span class="number">#4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">JUMP</span></span><br><span class="line">       <span class="keyword">CMP</span> <span class="built_in">R4</span>,#-<span class="number">4</span></span><br><span class="line">       <span class="keyword">BNE</span> LOOP2</span><br><span class="line">       <span class="keyword">SUB</span> <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">#4</span></span><br><span class="line">       <span class="keyword">LDR</span> <span class="built_in">R3</span>,[<span class="built_in">R1</span>,<span class="number">#4</span>]</span><br><span class="line">       <span class="keyword">CMP</span> <span class="built_in">R2</span>,<span class="built_in">R3</span></span><br><span class="line">       <span class="keyword">BEQ</span> LOOP1</span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R3</span>,[<span class="built_in">R5</span>]</span><br><span class="line">       <span class="keyword">STR</span> <span class="built_in">R2</span>,[<span class="built_in">R1</span>,<span class="number">#4</span>]</span><br><span class="line">       <span class="keyword">B</span> LOOP1</span><br><span class="line"></span><br><span class="line"><span class="symbol">STOP</span></span><br><span class="line">       <span class="keyword">B</span> STOP</span><br><span class="line">       <span class="meta">END</span></span><br></pre></td></tr></table></figure>
<hr>
<p>​    5. 使用汇编语言调用 C 语言实现 20!。</p>
<ul>
<li>test.s</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">     <span class="meta">EXPORT</span> test</span><br><span class="line">     <span class="meta">AREA</span> test,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line">     <span class="meta">IMPORT</span> CFUN               </span><br><span class="line">     <span class="meta">ENTRY</span></span><br><span class="line">     <span class="meta">CODE32</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">START</span></span><br><span class="line">     <span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="number">#20</span></span><br><span class="line">     <span class="keyword">BL</span> CFUN</span><br><span class="line"></span><br><span class="line"><span class="symbol">STOP</span></span><br><span class="line">     <span class="keyword">B</span> STOP</span><br><span class="line">     <span class="meta">END</span></span><br></pre></td></tr></table></figure>
<ul>
<li>main.c</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">CFUN</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(i;i&lt;=a;i++)</span><br><span class="line">         result=result*i;</span><br><span class="line">         </span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>​    6. 使用汇编语言调用 C 语言实现 5 个数（5，7，9，11，13）加法。</p>
<ul>
<li>addl.s</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">     <span class="meta">AREA</span> ADDL,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line">    <span class="meta">IMPORT</span> CAL</span><br><span class="line">    <span class="meta">ENTRY</span></span><br><span class="line">    <span class="meta">CODE32</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">START</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="number">#5</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">R1</span>,<span class="number">#7</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">R2</span>,<span class="number">#9</span></span><br><span class="line">    <span class="keyword">MOV</span> <span class="built_in">R3</span>,<span class="number">#11</span></span><br><span class="line">    <span class="keyword">MOV</span>   <span class="built_in">R4</span>,<span class="number">#13</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">STR</span> <span class="built_in">R4</span>,[<span class="built_in">SP</span>,#-<span class="number">4</span>]!</span><br><span class="line">    <span class="keyword">BL</span> CAL</span><br><span class="line"></span><br><span class="line"><span class="symbol">STOP</span></span><br><span class="line">     <span class="keyword">B</span> STOP</span><br><span class="line">    <span class="meta">END</span></span><br></pre></td></tr></table></figure>
<ul>
<li>main.c</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">CAL(<span class="params">int</span> <span class="params">a</span>,<span class="params">int</span> <span class="params">b</span>,<span class="params">int</span> <span class="params">c</span>, <span class="params">int</span> <span class="params">d</span>, <span class="params">int</span> <span class="params">e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">int</span> result = a + b + c + d + e;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>​    7. 使用C语言调用汇编语言实现 21!。</p>
<ul>
<li>test.s</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">     <span class="meta">AREA</span> test,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line">     <span class="meta">EXPORT</span> Factorial</span><br><span class="line"></span><br><span class="line"><span class="symbol">Factorial</span></span><br><span class="line">     <span class="keyword">MOV</span> <span class="built_in">R7</span>,<span class="built_in">R0</span></span><br><span class="line">     <span class="keyword">MOV</span> <span class="built_in">R8</span>,<span class="number">#0</span></span><br><span class="line">     <span class="keyword">MOV</span> <span class="built_in">R9</span>,<span class="number">#0</span></span><br><span class="line">     <span class="keyword">SUB</span> <span class="built_in">R0</span>,<span class="built_in">R7</span>,<span class="number">#1</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Loop</span></span><br><span class="line">     <span class="keyword">MOV</span> <span class="built_in">R1</span>,<span class="built_in">R8</span></span><br><span class="line">     <span class="keyword">UMULL</span> <span class="built_in">R7</span>,<span class="built_in">R8</span>,<span class="built_in">R0</span>,<span class="built_in">R7</span></span><br><span class="line">     <span class="keyword">MLA</span> <span class="built_in">R8</span>,<span class="built_in">R1</span>,<span class="built_in">R0</span>,<span class="built_in">R8</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">MOV</span> <span class="built_in">R2</span>,<span class="built_in">R9</span></span><br><span class="line">     <span class="keyword">UMULL</span> <span class="built_in">R1</span>,<span class="built_in">R9</span>,<span class="built_in">R0</span>,<span class="built_in">R1</span></span><br><span class="line">     <span class="keyword">MLA</span> <span class="built_in">R9</span>,<span class="built_in">R2</span>,<span class="built_in">R0</span>,<span class="built_in">R9</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">SUBS</span> <span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="number">#1</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">BNE</span> Loop</span><br><span class="line">     <span class="keyword">LDR</span> <span class="built_in">R0</span>,<span class="number">=0x00000000</span></span><br><span class="line">     <span class="keyword">STMIA</span> <span class="built_in">R0</span>,&#123;<span class="built_in">R7</span>,<span class="built_in">R8</span>,<span class="built_in">R9</span>&#125;</span><br><span class="line">     <span class="keyword">MOV</span> <span class="built_in">PC</span>,<span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<ul>
<li>main.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">char</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> num=<span class="number">21</span>;</span><br><span class="line">     Factorial(num);</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>​    8. 使用C语言调用汇编语言实现 5 个数（5，7，9，11，13）加法。</p>
<ul>
<li>test.s</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">     <span class="meta">AREA</span> test,<span class="meta">CODE</span>,<span class="meta">READONLY</span></span><br><span class="line">     <span class="meta">EXPORT</span> Add</span><br><span class="line"></span><br><span class="line"><span class="symbol">Add</span></span><br><span class="line">     <span class="keyword">ADD</span> <span class="built_in">R6</span>,<span class="built_in">R0</span>,<span class="built_in">R1</span></span><br><span class="line">     <span class="keyword">ADD</span> <span class="built_in">R6</span>,<span class="built_in">R6</span>,<span class="built_in">R2</span></span><br><span class="line">     <span class="keyword">ADD</span> <span class="built_in">R6</span>,<span class="built_in">R6</span>,<span class="built_in">R3</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">LDR</span> <span class="built_in">R4</span>,[<span class="built_in">SP</span>,<span class="number">#0</span>]</span><br><span class="line">     <span class="keyword">ADD</span> <span class="built_in">R6</span>,<span class="built_in">R6</span>,<span class="built_in">R4</span></span><br><span class="line">     <span class="keyword">LDR</span> <span class="built_in">R0</span>,<span class="number">=0x00000000</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">STMIA</span> <span class="built_in">R0</span>,&#123;<span class="built_in">R6</span>&#125;</span><br><span class="line">     <span class="keyword">MOV</span> <span class="built_in">PC</span>,<span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<ul>
<li>main.c</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern void <span class="constructor">Add(<span class="params">char</span> <span class="params">a</span>,<span class="params">char</span> <span class="params">b</span>,<span class="params">char</span> <span class="params">c</span>,<span class="params">char</span> <span class="params">d</span>,<span class="params">char</span> <span class="params">e</span>)</span>;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="constructor">Add(5,7,9,11,13)</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <div>
       
        <div>
     
        <div style="text-align:center;color:#bfbfbf;font-size:16px;"> 
            <span>-------- 本文结束 </span>
                <i class="fa fa-balance-scale" aria-hidden="true"></i> 
            <span> 感谢阅读 --------</span> 
        </div> 
    
</div> 
      
    </div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 嵌入式</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 复习</a>
          </div>

      <div>
        
          
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/embedded_sys_review/">嵌入式系统与组成原理—提纲</a></p>
  <p><span>文章作者:</span><a href="/" title="访问  的个人博客"></a></p>
  <p><span>发布时间:</span>2020年12月01日 - 16:12</p>
  <p><span>最后更新:</span>2022年08月27日 - 14:08</p>
  <p><span>原始链接:</span><a href="/embedded_sys_review/" title="嵌入式系统与组成原理—提纲">https://megalomania.icu/embedded_sys_review/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://megalomania.icu/embedded_sys_review/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"  aria-hidden="true"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
	  $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
	});
    });  
</script>

        
      </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/cn_computer_his/" rel="prev" title="中国计算机发展简史">
      <i class="fa fa-chevron-left"></i> 中国计算机发展简史
    </a></div>
      <div class="post-nav-item">
    <a href="/undefined/" rel="next" title="testpage">
      testpage <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">一、嵌入式系统的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E6%80%BB%E7%BB%93"><span class="nav-text">1、 嵌入式计算机发展总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">2、嵌入式系统的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%88%91%E5%9B%BD%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A1%8C%E4%B8%9A%E5%AE%9A%E4%B9%89"><span class="nav-text">3、我国嵌入式系统的行业定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="nav-text">4、嵌入式系统的组成结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E7%A1%AC%E4%BB%B6%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">5、硬件基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">6、嵌入式系统软件的层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81BootLoader"><span class="nav-text">7、BootLoader</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81ARM%E6%8A%80%E6%9C%AF%E4%B8%8EARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">二、ARM技术与ARM体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="nav-text">1、计算机体系结构分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81ISA%EF%BC%88Instruction-Set-Architecture%EF%BC%89%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">2、ISA（Instruction-Set Architecture）指令集体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81-ISA%E6%A8%A1%E5%9E%8B"><span class="nav-text">3、 ISA模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81ARM"><span class="nav-text">4、ARM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81ARM7%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E5%88%97"><span class="nav-text">5、ARM7微处理器系列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81ARM%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-text">6、ARM内核模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81ARM%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="nav-text">7、ARM流水线技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89ARM7%E4%B8%89%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-text">（1）ARM7三级流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89ARM9%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="nav-text">（2）ARM9内核结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81ARM%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-text">8、ARM处理器的工作模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81ARM-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">9、ARM 寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">10、程序状态寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81%E7%A8%8B%E5%BA%8F%E6%8C%87%E9%92%88PC-r15"><span class="nav-text">11、程序指针PC (r15)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81ARM%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">12、ARM异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%BC%82%E5%B8%B8%E5%85%A5%E5%8F%A3"><span class="nav-text">（1）异常入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%93%8D%E5%BA%94"><span class="nav-text">（2）对异常的响应</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81%E5%A4%96%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-text">13、外中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89FIQ-vs-IRQ"><span class="nav-text">（1）FIQ vs IRQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%AD%E6%96%AD%E9%87%8D%E6%96%B0%E4%BD%BF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">（2）中断重新使能的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-text">（3）软中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89SWI%E8%B0%83%E7%94%A8"><span class="nav-text">（4）SWI调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%AD%98%E5%8F%96SWI%E5%8F%B7"><span class="nav-text">（5）存取SWI号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E5%AD%98%E5%8F%96SWI%E5%8F%82%E6%95%B0"><span class="nav-text">（6）存取SWI参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E5%A4%8D%E4%BD%8D"><span class="nav-text">（7）复位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E6%9C%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-text">（8）未定义指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%889%EF%BC%89%E9%A2%84%E5%8F%96%E5%BC%82%E5%B8%B8"><span class="nav-text">（9）预取异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8"><span class="nav-text">（10）数据异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-text">（11）异常返回地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8812%EF%BC%89%E4%BB%8ESWIs%E5%92%8C%E6%9C%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E8%BF%94%E5%9B%9E"><span class="nav-text">（12）从SWIs和未定义指令返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8813%EF%BC%89%E4%BB%8EFIQs%E5%92%8CIRQs%E5%92%8C%E9%A2%84%E5%8F%96%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E"><span class="nav-text">（13）从FIQs和IRQs和预取异常返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8814%EF%BC%89%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E"><span class="nav-text">（14）从数据异常返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8815%EF%BC%89%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-text">（15）异常返回指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-text">14、 存储方式与存储器映射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="nav-text">（1）数据存储格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%9D%9E%E5%AF%B9%E9%BD%90%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-text">（2）非对齐存储器地址访问问题分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%9D%9E%E5%AF%B9%E9%BD%90%E7%9A%84%E6%8C%87%E4%BB%A4%E9%A2%84%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="nav-text">1* 非对齐的指令预取操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%9D%9E%E5%AF%B9%E9%BD%90%E5%9C%B0%E5%9D%80%E5%86%85%E5%AD%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="nav-text">2* 非对齐地址内存的访问操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81ARM%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90"><span class="nav-text">15、ARM流水线技术分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89ARM7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="nav-text">（1）ARM7流水线技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89ARM9TDMI%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-text">（2）ARM9TDMI流水线</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">三、ARM指令集寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81ARM%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="nav-text">1、ARM指令的编码格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%B8%80%E8%88%AC%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="nav-text">（1）一般编码格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8C%87%E4%BB%A4%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-text">（2）指令条件码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">2、数据处理指令寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E7%AC%AC2%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E6%9E%84%E6%88%90%E6%96%B9%E5%BC%8F"><span class="nav-text">（1）数据处理指令第2操作数的构成方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%AB%8B%E5%8D%B3%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">1* 立即数方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">2* 寄存器方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E4%BD%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">3*寄存器移位方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%85%B7%E4%BD%93%E5%AF%BB%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="nav-text">（2）具体寻址类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%AC%AC%E4%BA%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E4%B8%BA%E7%AB%8B%E5%8D%B3%E6%95%B0"><span class="nav-text">1* 第二操作数为立即数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%AC%AC%E4%BA%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">2* 第二操作数为寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%AC%AC%E4%BA%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E4%BD%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%94%E7%A7%BB%E4%BD%8D%E7%9A%84%E4%BD%8D%E6%95%B0%E4%B8%BA%E4%B8%80%E4%B8%AA5%E4%BD%8D%E7%9A%84%E7%AB%8B%E5%8D%B3%E6%95%B0"><span class="nav-text">3* 第二操作数为寄存器移位方式，且移位的位数为一个5位的立即数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%AC%AC%E4%BA%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E4%BD%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%94%E7%A7%BB%E4%BD%8D%E6%95%B0%E5%80%BC%E6%94%BE%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD"><span class="nav-text">4* 第二操作数为寄存器移位方式，且移位数值放在寄存器中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%AC%AC%E4%BA%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8CRRX%E7%A7%BB%E4%BD%8D%E5%BE%97%E5%88%B0"><span class="nav-text">5* 第二操作数为寄存器进行RRX移位得到</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="nav-text">（3）寄存器寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E7%AC%AC%E4%BA%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">（4）第二操作数为寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89Load-Store%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="nav-text">（5）Load&#x2F;Store指令寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="nav-text">1* 寄存器间接寻址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E5%9F%BA%E5%9D%80%E5%8A%A0%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="nav-text">（6）基址加变址寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E5%AD%97%E3%80%81%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%AD%97%E8%8A%82%E5%AF%BB%E5%9D%80"><span class="nav-text">（7）字、无符号字节寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Addressing-mode%E4%B8%AD%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B8%BA%E7%AB%8B%E5%8D%B3%E6%95%B0"><span class="nav-text">1* Addressing_mode中的偏移量为立即数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Addressing-mode%E4%B8%AD%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC"><span class="nav-text">2* Addressing_mode中的偏移量为寄存器的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F%E9%80%9A%E8%BF%87%E5%AF%84%E5%AD%98%E5%99%A8%E7%A7%BB%E4%BD%8D%E5%BE%97%E5%88%B0"><span class="nav-text">偏移量通过寄存器移位得到</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E5%8D%8A%E5%AD%97%E3%80%81%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%AD%97%E8%8A%82%E5%AF%BB%E5%9D%80"><span class="nav-text">（8）半字、有符号字节寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Addressing-mode%E4%B8%AD%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B8%BA%E7%AB%8B%E5%8D%B3%E6%95%B0-1"><span class="nav-text">1* Addressing_mode中的偏移量为立即数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Addressing-mode%E4%B8%AD%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC-1"><span class="nav-text">2* Addressing_mode中的偏移量为寄存器的值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%889%EF%BC%89%E6%89%B9%E9%87%8FLoad-Store%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">（9）批量Load&#x2F;Store指令寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="nav-text">1* 编码格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="nav-text">2* 内存操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A0%86%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-text">3* 堆栈操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%9D%97%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%A0%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-text">4* 块拷贝与栈操作的对应关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">（7）协处理器指令寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F"><span class="nav-text">1* 内存地址索引格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E9%9D%9E%E7%B4%A2%E5%BC%95%E6%A0%BC%E5%BC%8F"><span class="nav-text">2* 内存地址非索引格式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E7%B3%BB%E7%BB%9F"><span class="nav-text">四、ARM指令集系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-text">1、数据处理指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-text">（1）基本数据处理指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="nav-text">1* 数据传输指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-MOV%E6%8C%87%E4%BB%A4"><span class="nav-text">1. MOV指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-MVN%E6%8C%87%E4%BB%A4"><span class="nav-text">2. MVN指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-text">2* 算数运算指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-ADD%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">1. ADD加法指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ADC%E5%B8%A6C%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">2. ADC带C标志位的加法指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-SUB%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">3. SUB减法指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-SBC%E5%B8%A6C%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">4. SBC带C标志位的减法指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-RSB%E9%80%86%E5%90%91%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">5. RSB逆向减法指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-RSC%E5%B8%A6C%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E9%80%86%E5%90%91%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">6. RSC带C标志位的逆向减法指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-text">3* 逻辑运算指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-AND%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-text">1. AND与逻辑运算指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ORR%E6%88%96%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-text">2. ORR或逻辑运算指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-EOR%E5%BC%82%E6%88%96%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-text">3. EOR异或逻辑运算指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-BIC%E6%B8%85%E9%99%A4%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-text">4. BIC清除逻辑运算指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="nav-text">4* 比较指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-CMP%E7%9B%B8%E5%87%8F%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="nav-text">1. CMP相减比较指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-CMN%E8%B4%9F%E6%95%B0%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="nav-text">2. CMN负数比较指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-TST%E4%BD%8D%E6%B5%8B%E8%AF%95%E6%8C%87%E4%BB%A4"><span class="nav-text">3. TST位测试指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-TEQ%E7%9B%B8%E7%AD%89%E6%B5%8B%E8%AF%95%E6%8C%87%E4%BB%A4"><span class="nav-text">4. TEQ相等测试指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">（2）乘法指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-32%E4%BD%8D%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">1* 32位乘法指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-MUL"><span class="nav-text">1. MUL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-MLA"><span class="nav-text">2. MLA</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-64%E4%BD%8D%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">2* 64位乘法指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-UMULL"><span class="nav-text">1. UMULL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-UMLAL"><span class="nav-text">2. UMLAL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-SMULL"><span class="nav-text">3. SMULL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-SMLAL"><span class="nav-text">4. SMLAL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%9D%82%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-text">（3）杂类的数据处理指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81ARM%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4"><span class="nav-text">2、ARM分支指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-text">跳转指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4B"><span class="nav-text">1* 分支指令B</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B8%A6%E9%93%BE%E6%8E%A5%E7%9A%84%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4BL"><span class="nav-text">2* 带链接的分支指令BL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B8%A6%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4-BX"><span class="nav-text">3* 带状态切换的跳转指令 BX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B8%A6%E9%93%BE%E6%8E%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4-BLX"><span class="nav-text">4* 带链接和状态切换的跳转指令 BLX</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%94%B1%E7%A8%8B%E5%BA%8F%E6%A0%87%E5%8F%B7%E7%BB%99%E5%87%BA%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80"><span class="nav-text">1. 由程序标号给出目标地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%86%85%E5%AE%B9%E4%BD%9C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80"><span class="nav-text">2. 寄存器的内容作为目标地址</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">3、加载&#x2F;存储指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E5%AD%97%E3%80%81%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%AD%97%E8%8A%82%E6%8C%87%E4%BB%A4"><span class="nav-text">（1）加载&#x2F;存储字、无符号字节指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-LDR-STR%E6%8C%87%E4%BB%A4"><span class="nav-text">1* LDR&#x2F;STR指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-LDRB-STRB%E6%8C%87%E4%BB%A4"><span class="nav-text">2* LDRB&#x2F;STRB指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8D%8A%E5%AD%97%E3%80%81%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%AD%97%E8%8A%82%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-text">（2）半字、有符号字节访问指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%89%B9%E9%87%8F%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">4、批量加载&#x2F;存储指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%89%B9%E9%87%8F%E5%AD%97%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">（1）基本批量字数据加载&#x2F;存储指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%89%B9%E9%87%8F%E5%AD%97%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">（2）用户模式下的批量字数据加载&#x2F;存储指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%B8%A6PSR%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%B9%E9%87%8F%E5%AD%97%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4"><span class="nav-text">（3）带PSR操作的批量字数据加载指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-text">5、交换指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AD%97%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-text">（1）字数据交换指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-text">（2）字节数据交换指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8PSR%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-text">6、程序状态寄存器PSR访问指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%AF%BB%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">（1）读程序状态寄存器指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%86%99%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">（2）写程序状态寄存器指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-text">7、协处理器操作指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-text">（1）协处理器数据操作指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">（2）协处理器加载&#x2F;存储指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4LDC"><span class="nav-text">1* 协处理器数据加载指令LDC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4STC"><span class="nav-text">2* 协处理器数据存储指令STC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89ARM%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="nav-text">（3）ARM寄存器与协处理器寄存器数据传输指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-ARM%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%B0%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4MCR"><span class="nav-text">1* ARM寄存器到协处理器寄存器的数据传送指令MCR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%B0ARM%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4MRC"><span class="nav-text">2* 协处理器寄存器到ARM寄存器的数据传送指令MRC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E6%8C%87%E4%BB%A4"><span class="nav-text">8、异常产生指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="nav-text">（1）软中断指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%96%AD%E7%82%B9%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="nav-text">（2）断点中断指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81ARM%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4%E4%B8%8E%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">五、ARM汇编伪指令与伪操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-text">1、汇编语言伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BC%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">（1）伪指令的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%A6%E5%8F%B7"><span class="nav-text">（2）汇编中的一些符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%B8%B8%E7%94%A8%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-text">（3）常用伪指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-text">（4）ARM汇编语言伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%A4%A7%E8%8C%83%E5%9B%B4%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%8F%96%E4%BC%AA%E6%8C%87%E4%BB%A4LDR"><span class="nav-text">1* 大范围地址读取伪指令LDR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%AD%E7%AD%89%E8%8C%83%E5%9B%B4%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%8F%96%E4%BC%AA%E6%8C%87%E4%BB%A4ADRL"><span class="nav-text">2* 中等范围地址读取伪指令ADRL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B0%8F%E8%8C%83%E5%9B%B4%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%8F%96%E4%BC%AA%E6%8C%87%E4%BB%A4ADR"><span class="nav-text">3* 小范围地址读取伪指令ADR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%A9%BA%E6%93%8D%E4%BD%9C%E4%BC%AA%E6%8C%87%E4%BB%A4NOP"><span class="nav-text">4* 空操作伪指令NOP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89Thumb%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-text">（5）Thumb汇编语言伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%A4%A7%E8%8C%83%E5%9B%B4%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%8F%96%E4%BC%AA%E6%8C%87%E4%BB%A4LDR-1"><span class="nav-text">1* 大范围地址读取伪指令LDR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B0%8F%E8%8C%83%E5%9B%B4%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%8F%96%E4%BC%AA%E6%8C%87%E4%BB%A4ADR"><span class="nav-text">2* 小范围地址读取伪指令ADR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%A9%BA%E6%93%8D%E4%BD%9C%E4%BC%AA%E6%8C%87%E4%BB%A4NOP"><span class="nav-text">3* 空操作伪指令NOP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">2、汇编语言伪操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81GNU-ARM%E6%B1%87%E7%BC%96%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">3、GNU ARM汇编伪操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">（1）符号定义伪操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%93%8D%E4%BD%9C-equ%E6%88%96-set"><span class="nav-text">1* 常量定义伪操作.equ或.set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%93%8D%E4%BD%9C-equiv"><span class="nav-text">2* 常量定义伪操作.equiv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%E4%BC%AA%E6%93%8D%E4%BD%9C-global%E6%88%96-globl"><span class="nav-text">3* 声明全局常量伪操作.global或.globl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%A3%B0%E6%98%8E%E5%A4%96%E9%83%A8%E5%B8%B8%E9%87%8F%E4%BC%AA%E6%93%8D%E4%BD%9C-extern"><span class="nav-text">4* 声明外部常量伪操作.extern</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">（2）数据定义伪操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AD%97%E8%8A%82%E5%AE%9A%E4%B9%89-byte"><span class="nav-text">1* 字节定义.byte</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8D%8A%E5%AD%97%E5%AE%9A%E4%B9%89-hword%E6%88%96-short"><span class="nav-text">2* 半字定义.hword或.short</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%97%E5%AE%9A%E4%B9%89-word%E6%88%96-int%E6%88%96-long"><span class="nav-text">3* 字定义.word或.int或.long</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9A%E4%B9%89-ascii%E5%92%8C-asciz%E6%88%96-string"><span class="nav-text">4* 字符串定义.ascii和.asciz或.string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%8F%8C%E5%AD%97%E5%AE%9A%E4%B9%89-quad"><span class="nav-text">5* 双字定义.quad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%9B%9B%E5%AD%97%E5%AE%9A%E4%B9%89-octa"><span class="nav-text">6* 四字定义.octa</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AE%9A%E4%B9%89-float%E6%88%96-single"><span class="nav-text">7* 单精度浮点数定义.float或.single</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AE%9A%E4%B9%89-double"><span class="nav-text">8* 双精度浮点数定义.double</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E9%87%8D%E5%A4%8D%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E5%AE%9A%E4%B9%89-fill"><span class="nav-text">9* 重复内存单元定义.fill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E9%9B%B6%E5%A1%AB%E5%85%85%E5%AD%97%E8%8A%82%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E5%AE%9A%E4%B9%89-zero"><span class="nav-text">10* 零填充字节内存单元定义.zero</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E5%9B%BA%E5%AE%9A%E5%A1%AB%E5%85%85%E5%AD%97%E8%8A%82%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E5%AE%9A%E4%B9%89-space%E6%88%96-skip"><span class="nav-text">11* 固定填充字节内存单元定义.space或.skip</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E5%A3%B0%E6%98%8E%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E6%B1%A0-ltorg"><span class="nav-text">12* 声明数据缓冲池.ltorg</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">（3）汇编与反汇编代码控制伪操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AF%86%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">1* 指令集类型标识伪操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%AE%B5%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">2* 段属性定义伪操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%AE%B5%E8%B5%B7%E5%A7%8B%E5%A3%B0%E6%98%8E%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">3* 段起始声明伪操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E4%BC%AA%E6%93%8D%E4%BD%9C-align%E6%88%96-balign"><span class="nav-text">4* 对齐方式设置伪操作.align或.balign</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE%E4%BC%AA%E6%93%8D%E4%BD%9C-org"><span class="nav-text">5* 代码位置设置伪操作.org</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E9%A2%84%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-text">（4）预定义控制伪操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E4%BC%AA%E6%93%8D%E4%BD%9C-if"><span class="nav-text">1* 条件编译伪操作.if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%93%8D%E4%BD%9C-macro"><span class="nav-text">2* 宏定义伪操作.macro</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BC%AA%E6%93%8D%E4%BD%9C-include"><span class="nav-text">3* 文件包含伪操作.include</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">六、汇编语言程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81ARM%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5"><span class="nav-text">1、ARM编译环境下汇编语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89ADS%E7%8E%AF%E5%A2%83%E4%B8%8BARM%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F"><span class="nav-text">（1）ADS环境下ARM汇编语句格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89ADS%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%AC%A6%E5%8F%B7%E8%A7%84%E5%88%99"><span class="nav-text">（2）ADS编译环境下汇编语句中符号规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%AC%A6%E5%8F%B7%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">1* 符号命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B8%B8%E9%87%8F"><span class="nav-text">2* 常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8F%98%E9%87%8F"><span class="nav-text">3* 变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="nav-text">4* 字符串表达式操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8F%96%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6LEN"><span class="nav-text">1. 取符串的长度LEN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-CHR"><span class="nav-text">2. CHR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-STR"><span class="nav-text">3. STR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-LEFT"><span class="nav-text">4. LEFT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-RIGHT"><span class="nav-text">5. RIGHT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-CC"><span class="nav-text">6. CC</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%9C%B0%E5%9D%80%E6%A0%87%E5%8F%B7"><span class="nav-text">5* 地址标号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%B1%80%E9%83%A8%E6%A0%87%E5%8F%B7"><span class="nav-text">6* 局部标号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81GNU%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5%E4%B8%8E%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E"><span class="nav-text">2、GNU环境下汇编语句与编译说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89GNU%E7%8E%AF%E5%A2%83%E4%B8%8BARM%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F"><span class="nav-text">（1）GNU环境下ARM汇编语句格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89GNU%E7%8E%AF%E5%A2%83%E4%B8%8BARM%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91"><span class="nav-text">（2）GNU环境下ARM汇编程序编译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-text">1* 预处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B3%A8%E9%87%8A"><span class="nav-text">2* 注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%AC%A6%E5%8F%B7"><span class="nav-text">3* 符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%AE%B5%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-text">4* 段与重定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E"><span class="nav-text">5* 符号说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-label"><span class="nav-text">1. label</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BB%99%E7%AC%A6%E5%8F%B7%E8%B5%8B%E5%80%BC"><span class="nav-text">2. 给符号赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%AC%A6%E5%8F%B7%E5%90%8D"><span class="nav-text">3. 符号名</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-text">3、ARM汇编语言程序设计规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%B1%87%E7%BC%96%E5%99%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%90%8D%E7%A7%B0"><span class="nav-text">（1）汇编器预定义的寄存器名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-text">（2）ARM汇编语言程序设计规范</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B"><span class="nav-text">七、ARM汇编语言与嵌入式C混合编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8FC%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83"><span class="nav-text">1、嵌入式C编程规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-%E5%B5%8C%E5%85%A5%E5%BC%8FC%E7%A8%8B%E5%BA%8F%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83"><span class="nav-text">（1） 嵌入式C程序书写规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">（2）命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%B3%A8%E9%87%8A%E8%AF%B4%E6%98%8E"><span class="nav-text">（3）注释说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8FC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-text">2、嵌入式C程序设计中的位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8C%89%E4%BD%8D%E4%B8%8E%E6%93%8D%E4%BD%9C"><span class="nav-text">（1）按位与操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8C%89%E4%BD%8D%E6%88%96%E6%93%8D%E4%BD%9C"><span class="nav-text">（2）按位或操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C"><span class="nav-text">（3）按位异或操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%8F%96%E5%8F%8D%E6%93%8D%E4%BD%9C"><span class="nav-text">（4）取反操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-text">（5）移位操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8FC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-text">3、嵌入式C程序设计中的几点说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89volatile%E9%99%90%E5%88%B6%E7%AC%A6"><span class="nav-text">（1）volatile限制符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%9C%B0%E5%9D%80%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88"><span class="nav-text">（2）地址强制转换与多级指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9C%B0%E5%9D%80%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-text">1* 地址强制转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88"><span class="nav-text">2* 多级指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">（3）预处理的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%8F%E5%AE%9A%E4%B9%89-define"><span class="nav-text">1* 宏定义(#define)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F"><span class="nav-text">1. 不带参数的宏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">2. 带参数的宏定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B8%A6%E5%8F%82%E5%AE%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3. 带参宏与函数的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-include"><span class="nav-text">2* 文件包含(#include)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-text">3* 条件编译</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BD%A2%E5%BC%8F1"><span class="nav-text">1. 形式1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BD%A2%E5%BC%8F2"><span class="nav-text">2. 形式2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%BD%A2%E5%BC%8F3"><span class="nav-text">3. 形式3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8FC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A0%BC%E5%BC%8F"><span class="nav-text">4、嵌入式C程序设计格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-text">（1）可重入函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">（2）中断处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">（3）模块化程序设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A0%87%E5%87%86ATPCS%E4%B8%8EAAPCS"><span class="nav-text">5、过程调用标准ATPCS与AAPCS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-text">（1）寄存器使用规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E6%A0%88%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-text">（2）数据栈使用规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%A0%86%E6%A0%88%E5%88%86%E7%B1%BB"><span class="nav-text">1* 堆栈分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9D%97%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%A0%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-text">2* 块拷贝与栈操作的对应关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="nav-text">（3）参数传递规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%8F%AF%E5%8F%98%E7%9A%84%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="nav-text">1* 参数个数可变的子程序参数传递规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="nav-text">2* 参数个数固定的子程序参数传递规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E8%A7%84%E5%88%99"><span class="nav-text">3* 子程序结果返回规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B"><span class="nav-text">6、ARM汇编语言与嵌入式C混合编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96"><span class="nav-text">（1）内嵌汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-ARM%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="nav-text">1* ARM开发工具编译环境下内嵌汇编语法格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-GNU-ARM%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="nav-text">2* GNU ARM环境下内嵌汇编语法格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-text">3* 内嵌汇编的局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%89%A9%E7%90%86%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">1. 物理寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%87%E5%8F%B7%E3%80%81%E5%B8%B8%E9%87%8F%E5%8F%8A%E6%8C%87%E4%BB%A4%E5%B1%95%E5%BC%80"><span class="nav-text">2. 标号、常量及指令展开</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-text">3. 内存单元的分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-SWI%E5%92%8CBL%E6%8C%87%E4%BB%A4"><span class="nav-text">4. SWI和BL指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E5%99%A8%E4%B8%8Earmasm%E6%B1%87%E7%BC%96%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">4* 内嵌汇编器与armasm汇编器的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FC%E7%A8%8B%E5%BA%8F%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8"><span class="nav-text">（3）ARM汇编语言与嵌入式C程序相互调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8C%E7%A8%8B%E5%BA%8F"><span class="nav-text">1* 汇编程序调用C程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-C%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F"><span class="nav-text">2* C程序调用汇编程序</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81S3C44B0-S3C2410%E9%80%9A%E4%BF%A1%E4%B8%8ELCD%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF"><span class="nav-text">八、S3C44B0&#x2F;S3C2410通信与LCD接口技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#S3C44B0-S3C2410-UART"><span class="nav-text">S3C44B0&#x2F; S3C2410 UART</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89UART%E5%8E%9F%E7%90%86"><span class="nav-text">（1）UART原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-text">1* 串行通信的工作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E7%9A%84%E6%B3%A2%E7%89%B9%E7%8E%87"><span class="nav-text">2* 串行通信的波特率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="nav-text">3* 奇偶校验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="nav-text">4* 数据帧格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89S3C44B0-S3C2410-UART%E6%A8%A1%E5%9D%97"><span class="nav-text">（2）S3C44B0&#x2F; S3C2410 UART模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89S3C44B0-S3C2410-UART%E6%93%8D%E4%BD%9C"><span class="nav-text">（3）S3C44B0&#x2F; S3C2410 UART操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6"><span class="nav-text">1* 数据发送与接收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%87%AA%E5%8A%A8%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88AFC%EF%BC%89"><span class="nav-text">2* 自动流量控制（AFC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%87%AA%E7%8E%AF%E6%A8%A1%E5%BC%8F"><span class="nav-text">3* 自环模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%BA%A2%E5%A4%96%E6%A8%A1%E5%BC%8F"><span class="nav-text">4* 红外模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89UART%E4%B8%AD%E6%96%AD%E4%B8%8E%E6%B3%A2%E7%89%B9%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-text">（4）UART中断与波特率的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-UART%E4%B8%AD%E6%96%AD"><span class="nav-text">1* UART中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B3%A2%E7%89%B9%E7%8E%87%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-text">2* 波特率的产生</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89S3C44B0-S3C2410-UART%E4%B8%93%E7%94%A8%E5%8A%9F%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">（5）S3C44B0&#x2F; S3C2410 UART专用功能寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-UART%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8-ULCONn"><span class="nav-text">1* UART线控制寄存器(ULCONn)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-UART%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8UCONn"><span class="nav-text">2* UART控制寄存器UCONn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-UART-FIFO%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">3* UART FIFO控制寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-UART%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">4* UART调制解调器控制寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-UART-%E5%8F%91%E9%80%81-%E6%8E%A5%E6%94%B6%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">5* UART 发送&#x2F;接收状态寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-UART%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">6* UART错误状态寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-UART-FIFO%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">7* UART FIFO状态寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-UART-%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">8* UART 调制解调器状态寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-UART-%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">9* UART 发送缓冲寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-UART-%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">10* UART 接收缓冲寄存器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%AE%9E%E9%AA%8C%E6%BA%90%E7%A0%81"><span class="nav-text">九、实验源码</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shaw Wei"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Shaw Wei</p>
  <div class="site-description" itemprop="description">Just do it.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Shaw-W" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Shaw-W" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shaw.wei@qq.com" title="E-Mail → mailto:shaw.wei@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_44544583" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44544583" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备20050867号 </a>
  </div>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-balance-scale"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shaw Wei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<span id="sitetime"></span>
<script language=javascript>
	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* 
		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数
        */
		var t1 = Date.UTC(2020,06,01,04,00,00); //北京时间2018-2-13 00:00:00
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML="| 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>

<div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"r97PRG7qR4NHLbPKyHG6SI78-gzGzoHsz","app_key":"soFAbA0hxFx9sMHAnF3ExDYu","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
